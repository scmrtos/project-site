# Разработка расширения: профилировщик работы процессов
 
## Назначение

Профилировщик работы процессов&nbsp;– это объект, выполняющий действия по сбору информации об относительном времени активной работы процессов системы, её обработке и имеющий интерфейс, через который пользовательская программа может получить доступ к результатам профилировки.

Сбор информации об относительном времени работы процессов можно выполнить разными способами&nbsp;– в частности, методом сэмплирования текущего активного процесса и путём измерения времени работы процессов. В сущности, сам класс профилировщика может быть одним и тем же, а выбор реализации обоих методов выполнен с помощью организации способов взаимодействия профилировщика с объектами ОС и использования аппаратных ресурсов процессора.

Реализация самого класса профилировщика требует доступа к внутренностям ОС, но все эти потребности могут быть удовлетворены штатными средствами операционной системы, которые предоставляются пользователю для подобных целей. Таким образом, профилировщик времени активной работы процессов может быть выполнен в виде расширения ОС.

Цель данного примера&nbsp;– показать, как можно создать полезное средство, расширяющее функциональные возможности операционной системы не изменяя исходный код ОС. Дополнительные требования: 

  * разрабатываемый класс не должен накладывать ограничений на способы использования профилировщика&nbsp;– т.е. период сбора информации и место использования должны полностью определяться пользователем;
  * реализация должна быть как можно менее ресурсоёмкой, как по размеру исполняемого кода, так и по быстродействию, т.е., в частности, использование вычислений с плавающей точкой на платформах без аппаратной поддержки таковой должно быть исключено.

## Реализация

Профилировщик сам по себе выполняет две основные функции&nbsp;– это сбор информации об относительном времени активной работы процессов и обработка этой информации с целью получения результатов.

Оценка времени работы процесса может быть реализована на основе счётчика, который накапливает информацию об этом. Соответственно, для всех процессов системы потребуется массив таких счётчиков. Также потребуется массив переменных, хранящих результаты профилировки.

Итого, профилировщик должен содержать два массива переменных, функцию обновления счётчиков в соответствии с активностью процессов, функцию обработки значений счётчиков и сохранения результатов и функцию доступа к результатам профилировки. Для повышения гибкости использования основа профилировщика выполнена в виде шаблона&nbsp;– см. "Листинг&nbsp;1. Профилировщик".

```cpp
01    template <typename T>
02    class process_profiler : public OS::TKernelAgent
03    {
04        uint32_t time_interval();
05    public:
06        INLINE process_profiler();
07    
08        INLINE void advance_counters()
09        {
10            uint32_t elapsed = time_interval();
11            counters[ cur_proc_priority() ] += elapsed;
12        }
13    
14        INLINE T    get_result(uint_fast8_t index) { return result[index]; }
15        INLINE void process_data();
16    
17    protected:
18        volatile uint32_t  counters[OS::PROCESS_COUNT];
19                 T         result  [OS::PROCESS_COUNT];
20    };
```      
/// Caption
Листинг 1. Профилировщик
///

Профилировщик реализован как шаблон, параметр которого задаёт тип переменных, содержащих значения счётиков и результатов. Это позволяет выбрать наиболее подходящий вариант для конкретного применения. Предполагается, что параметром шаблона будет какой-либо числовой тип&nbsp;– например, `uint32_t` или `float`.

Если целевая платформа имеет аппаратную поддержку вычислений с плавающей точкой, то препочтительным будет выбор `float`&nbsp;– такая реализация будет, скорее всего, и быстрее, и компактнее. При отсуствии такой поддержки целесообразным будет вариант с целочисленными типами.

Помимо перечисленного выше присутствует очень важная функция `time_interval()` (4). Функция `time_interval()` определяется пользователем исходя из имеющихся у него ресурсов и выбранного способа сбора информации о времени работы процессов.

Вызов функции `advance_counters()` должен быть организован пользователем, и место вызова определяется выбранным методом профилировки&nbsp;– статистическим или измерительным.

Алгоритм обработки результатов сбора информации сводится к нормированию значений счётчиков, накопленных за период измерения,&nbsp;– см. "Листинг 2. Обработка результатов профилировки".

```cpp
01    template <typename T>
02    void process_profiler<T>::process_data()
03    {
04        // Use cache to make critical section fast as possible
05        uint32_t counters_cache[OS::PROCESS_COUNT];
06    
07        {
08            CritSect cs;
09            for(uint_fast8_t i = 0; i < OS::PROCESS_COUNT; ++i)
10            {
11                counters_cache[i] = counters[i];
12                counters[i]       = 0;
13            }
14        }
15    
16        uint32_t sum = 0;
17        for(uint_fast8_t i = 0; i < OS::PROCESS_COUNT; ++i)
18        {
19            sum += counters_cache[i];
20        }
21    
22        for(uint_fast8_t i = 0; i < OS::PROCESS_COUNT; ++i)
23        {
24            if constexpr(std::is_integral_v<T>)
25            {
26                result[i] = static_cast<uint64_t>(counters_cache[i])*10000/sum;
27            }
28            else
29            {
30                result[i] = static_cast<T>(counters_cache[i])/sum*100;
31            }
32        }
33    }
```
/// Caption
Листинг 2. Обработка результатов профилировки
///

Приведённый код, в частности, показывает, как осуществляется выбор обработки результата в зависимости от типа параметра шаблона (24).

Чтобы не блокировать работу прерываний на значительное время при обращении к массиву счётчиков[^1], производится копирование этого массива во временный массив, который и используется при дальнейшей обработке данных.

[^1]: Это обращение необходимо сделать атомарным, дабы не нарушить целостность алгоритма из-за возможности асинхронного изменения значений счётчиков при вызове функции `advance_counters()`.

При выборе целочисленного типа в качестве параметра шаблона принятое разрешение результата профилировки составляет одну сотую долю процента, и конечные результаты хранятся в сотых долях процента. Реализуется это путём нормирования величины каждого счётчика, предварительно умноженного на коэффициент, задающий разрешение результата[^2], к значению суммы величин всех счётчиков. 

[^2]: В данном случае этот коэффициент равен 10000, что и задаёт значение разрешения в 1/10000, которое соответствует 0.01%.

Из этих обстоятельств вытекает естественное ограничение на максимальную величину значения счётчика, которая используется при вычислениях. Например, если тип переменных, выполняющих функции счётчиков профилировщика, является 32‑разрядным беззнаковым целым, что позволяет представлять числа в диапазоне \(0..2^{32}-1 = 0..4294967295\), а при вычислениях производится умножение на коэффициент, равный 10000, то для предотвращения переполнения при вычислениях величина счётчика не должна превышать величину:

$$
N_{max} = \frac{2^{32} - 1}{10000} = \frac{4294967295}{10000} = 429496 \tag{1}
$$

Полученная величина является достаточно небольшой, поэтому, чтобы расширить данное оганичение, вычисления производятся с 64-разрядной точностью&nbsp;– значение счётчика приводится к 64-разрядному беззнаковому целому (26).

Также пользователь должен позаботиться о том, чтобы за период профилировки не происходило переполнения счётчиков, т.е. накопленная любым счётчиком величина не превышала значения  \(2^{32}-1\). Удовлетворение этого требования достигается путём согласования периода профилировки и максимальной величины возвращаемого функцией `time_interval()` значения.

Подключение профилировщика к проекту осуществляется путём включения заголовочного файла profiler.h в конфигурационный файл проекта scmRTOS_extensions.h.

### Использование

#### Статистический метод

В случае статистического метода вызов функции `advance_counters()` следует поместить в код, который периодически получает управление с равными интервалами времени,&nbsp;– например, в обработчик прерывания какого-либо таймера; в случае **scmRTOS** для этих целей хорошо подходит обработчик прерываний системного таймера, в этом случае вызов функции `advance_counters()` помещается в пользовательский хук системного таймера, вызов которого требуется разрешить при конфигурации. Функция `time_interval()` в этом случае всегда должна возвращать 1. 

#### Измерительный метод

При выборе измерительного метода профилировки вызов функции `advance_counters()` должен производиться при переключении контекстов, что может быть достигнуто путём помещения её вызова в пользовательский хук прерывания переключения контекстов.

Реализация функции `time_interval()` в этом случае получается несколько сложнее&nbsp;– функция должна возвращать значение, пропорциональное временному интервалу между предыдущим и текущим вызовами этой функции. Измерение этого временного интервала требует задействования тех или иных аппаратных ресурсов целевого процессора, и в большинстве случаев для этого подходит любой аппаратный таймер[^3], позволяющий получать величину таймерного регистра[^4].

[^3]: Некоторые процессоры, например Blackfin, имеют в своём составе специальный аппаратный счётчик тактов процессора, который инкрементируется на каждом такте, что позволяет очень просто организовать процесс измерения временных интервалов.

[^4]: Например, WatchDog Timer МК **MSP430**, который вполне подходит для использования его в качестве системного таймера, не годится для целей измерения временных интервалов, т.к. не позволяет программе получить доступ к своему счётному регистру.

Масштаб возвращаемого значения функции `time_interval()` должен быть согласован с периодом профилировки так, чтобы сумма всех возвращённых за период профилировки значений этой функции для любого процесса не превысила \(2^{32}-1\)&nbsp;– см.&nbsp;"Листинг&nbsp;3. Функция измерения временных интервалов".

```cpp
01    template<typename T>                         
02    uint32_t process_profiler<T>::time_interval()
03    {                                            
04        static uint32_t cycles;                  
05                                                 
06        uint32_t cyc = rpa(GTMR_CNT0_REG); // rpa stands for "read phisical memory"
07        uint32_t res = cyc - cycles;             
08        cycles       = cyc;                      
09                                                 
10        return res;                              
11    }                                            
```
/// Caption
Листинг 3. Функция измерения временных интервалов
///

В данном примере для измерения временных интервалов используется аппаратный счётчик тактов процессора, работающего на частоте 400&nbsp;МГц, что соответствует периоду следования тактов 2.5&nbsp;нс. Период профилировки выбран равным 1&nbsp;с. Отношение периодов таково, что счётчик успевает за период профилировки достичь величины:

$$
N = \frac{2}{5 \cdot 10^{-9}} = 400 000 000 \tag{2}
$$

Это значение значительно меньше, чем \(2^{32}-1\), поэтому никаких дополнительных действий производить не надо. В противном случае  возникла бы необходимость изменить код функции так, чтобы указанное условие соблюдалось.

Организация периода сбора информации об относительном времени активной работы процессов и способ отображения результатов профилировки находятся в ведении пользователя. 

Для удобства использования можно определить пользовательский класс, который добавит упростит применение, добавляя функцию отображения результатов&nbsp;– см. "Листинг 4. Пользовательский класс профилировщика".

```cpp
01    class ProcProfiler : public process_profiler<float> 
02    {                                                                  
03    public:                                                            
04        ProcProfiler() {}                                              
05        void get_results();                                            
06    };                                                                 

07    void ProcProfiler::get_results()                                      
08    {                                                                     
09        print("\n------------------------------\n");                      
10        print(" Pr |  CPU, %% | Slack | Name\n");                         
11        print("------------------------------\n");                        
12                                                                          
13        #if scmRTOS_DEBUG_ENABLE == 1                                     
14        for(uint_fast8_t i = OS::PROCESS_COUNT; i ; )                     
15        {                                                                 
16            --i;                                                          
17            float proc_busy;                                              
18            if constexpr(std::is_integral_v<proc_profiler_data_t>)        
19                proc_busy = proc_profiler.get_result(i)/100.0;            
20            else                                                          
21                proc_busy = proc_profiler.get_result(i);                  
22                                                                          
23            print(" %d  | %7.4f | %4d  | %s\n", i, proc_busy,             
24                      OS::get_proc(i)->stack_slack()*sizeof(stack_item_t),
25                      OS::get_proc(i)->name() );                          
26        }                                                                 
27        #endif                                                            
28                                                                          
29        print("------------------------------\n\n");                      
30    }                                                                     
```
/// Caption
Листинг 4. Пользовательский класс профилировщика
///

В завершение, остаётся только создать объект класса и обеспечить периодический вызов функции `process_data()`:

```cpp
ProcProfiler proc_profiler;
...

    ...
    proc_profiler.process_data();  // periodic call approx every 1 second
    ...

```

