# Порты

## Общие замечания

Ввиду больших отличий как аппаратных архитектур, так и средств разработки под них, возникает необходимость в специальной адаптации кода ОС[^ports-1] под них. Результатом этой работы является платформеннозависимая часть, которая в совокупности с общей частью и составляет порт под ту или иную платформу. Процесс подготовки платформеннозависимой части называется портированием.

[^ports-1]: Это касается не только ОС, но и других кроссплатформенных программ.

В настоящей главе будут рассмотрены, главным образом, платформеннозависимые части, их содержимое и особенности,  также дана краткая инструкция по портированию ОС, т.е. что нужно сделать, чтобы создать порт.

Платформеннозависимая часть каждой целевой платформы содержится в отдельной директории и минимально содержит три файла:

  * os_target.h – платформеннозависимые объявления и макросы.
  * os_target_asm.ext[^ports-2] – низкоуровневый код, функции переключения контекста, старта ОС.
  * os_target.cpp – определения функции инициализации стекового кадра процесса и функции обработчика прерывания от таймера, используемого в качестве системного.

[^ports-2]: Расширение ассемблерного файла для целевого процессора.

Настройка кода ОС на целевую платформу осуществляется путём:

  * определения специальных макросов препроцессора;
  * директивами условной трансляции;
  * определением типов, определяемых пользователем, реализация которых зависит от целевой платформы;
  * заданием псевдонимов некоторых типов;
  * определением функций, код которых вынесен на уровень порта.

Важной и "тонкой" частью кода порта является определение ассемблерных подпрограмм, осуществляющих старт системы, сохранение контекста прерываемого процесса, переключение указателей стека и восстановление контекста процесса, получившего управление, в том числе и обработчик программного прерывания, в теле которого производится переключение контекстов процессов. Чтобы реализовать этот код, от разработчика порта требуются глубокие знания целевой аппаратной архитектуры на низком уровне, а также умение использовать программный пакет (компилятор, ассемблер, линкер) для работы со "смешанными"[^ports-3] проектами. 

[^ports-3]: Т.е. содержащими исходные файлы на разных языках программирования&nbsp;– в нашем случае С++ и ассемблер целевой аппаратной платформы.

Процесс портирования сводится, главным образом, к определению объектов портирования и написанию платформеннозависимого кода.

## Объекты портирования

### Макросы

Существует ряд платформеннозависимых макросов, которые должны быть определены. Если значение макроса в том или ином порте не требуется, то макрос должен быть определён пустым. Перечень макросов и их описания приведены ниже.

```cpp
INLINE
```
Задаёт поведение функций при встраивании. Обычно состоит из платформеннозависимой директивы безусловного встраивания и ключевого слова `inline`.

```cpp
OS_PROCESS
```

Квалифицирует исполняемую функцию процесса. Содержит платформеннозависимый атрибут, указывающий компилятору, что функция не имеет возврата, поэтому preserved[^ports-4] регистры процессора можно использовать без сохранения. Это экономит код и пространство в стеке.

[^ports-4]: Те, значение которых перед использованием должно быть сохранено, а после использования восстановлено, чтобы вызывающая функция не получила искажения контекста при вызове другой функции.

```cpp
OS_INTERRUPT
```

Содержит платформеннозависимое расширение, используемое для квалификации обработчиков прерываний на целевой платформе.

```cpp
DUMMY_INSTR()
```

Макрос, определяющий пустую инструкцию целевого процессора (как правило, это инструкция `NOP`). Используется в цикле ожидания переключения контекстов в планировщике (в варианте с программным прерыванием переключения контекстов).

```cpp
INLINE_PROCESS_CTOR
```

Определяет поведение встраивания конструкторов процессов. Если нужно встраивание, то значение этого макроса должно `INLINE`, если  встраивание не нужно, то значение макроса должно быть оставлено пустым.

```cpp
SYS_TIMER_CRIT_SECT()
```

Используется в обработчике прерываний системного таймера и задаёт, будет ли использоваться в нём критическая секция, которая актуальна в случае, если целевой процессор имеет приоритетный многоуровневый контроллер прерываний, что может привести к тому, что обработчик прерываний от системного таймера может быть прерван в непредсказуемый момент другим, более высокоуровневым, обработчиком прерываний, который может производить доступ к тем же ресурсам ОС, что и обработчик прерываний от системного таймера.

```cpp
CONTEXT_SWITCH_HOOK_CRIT_SECT
```

Определяет, будет хук переключателя контекстов выполняться в критической секции или нет. Очень важно, чтобы хук переключателя контекстов выполнялся целостно по отношению к манипуляциям с переменными ядра (`SchedProcPriority`, в частности), а это означает, что во время выполнения хука не должен вызываться планировщик. Вызов планировщика может произойти из обработчика прерываний в случае, если процессор имеет аппаратный приоритетный контроллер прерываний и программное прерывание переключения контекстов имеет более низкий приоритет по сравнению с другими прерываниями.

В этом случае код хука переключателя контекстов должен выполняться в критической секции и значение макроса должно быть `TCritSect cs`. Это очень важный момент, если его не соблюсти, то в процессе работы системы будут возникать трудноуловимые ошибки, поэтому при портировании тут нужно проявить внимательность и аккуратность.

```cpp
SEPARATE_RETURN_STACK
```

Для платформ, имеющих отдельный стек возвратов, значение этого макроса должно быть равно 1. Для остальных платформ&nbsp;– 0.

### Типы

```cpp
stack_item_t
```
Псевдоним встроенного типа, задаёт тип элемента стека целевого процессора.

```cpp
status_reg_t
```
Псевдоним встроенного типа, соответствующий разрядности статусного регистра целевого процессора.

```cpp
TCritSect
```
Класс-"обёртка" для организации критической секции.

```cpp
TPrioMaskTable
```

Класс, содержащий таблицу масок (тегов) приоритетов. Служит для повышения эффективности работы системы. Может отсутствовать на некоторых платформах, на таких, где есть аппаратные средства для вычисления тегов по значению приоритета,&nbsp;– например, аппаратный shifter.

```cpp
TISRW
```
Класс-"обёртка" для обработчиков прерываний, в которых используются сервисы ОС.

### Функции

```cpp
get_prio_tag()
```

Преобразует номер приоритета в соответствующий тег. Функционально это сдвиг единицы в двоичном слове на количество позиций, равное номеру приоритета.

```cpp
highest_priority()
```

Возвращает номер приоритета, соответствующего тегу наиболее приоритетного процесса в карте процессов, переданной функции в качестве аргумента.

```cpp
disable_context_switch()
```

Запрещает переключение контекстов. В настоящее время реализуется путём запрещения прерываний.

```cpp
enable_context_switch()
```
Разрешает переключение контекстов. В настоящее время реализуется через разрешение прерываний.

```cpp
os_start()
```

Производит старт операционной системы. Сама функция реализована на ассемблере. Получает в качестве аргумента указатель стека самого приоритетного процесса и осуществляет передачу ему управления путём восстановления  контекста из его стека.

```cpp
os_context_switcher()
```

Функция, реализованная на ассемблере, производит переключение контекстов процессов в варианте с прямой передачей управления.

```cpp
context_switcher_isr()
```

Обработчик прерываний переключения контекстов. Реализуется на ассемблере. Производит сохранение контекста прерываемого процесса, переключение указателей стеков процессов путём вызова `context_switch_hook()`[^ports-5] и восстановление контекста активируемого процесса.

[^ports-5]: Через функцию-"обёртку"" `os_context_switch_hook()`, имеющую спецификацию связывания `"extern C"`.

```cpp
TBaseProcess::init_stack_frame()
```

Функция подготовки стекового кадра, которая формирует значения ячеек памяти в стеке таким образом, чтобы состояние стека было таким, как будто процесс, которому принадлежит стек, прерван и контекст процесса сохранён в стеке. Функция используется конструктором процесса и при рестарте процесса.

```cpp
system_timer_isr()
```

Обработчик прерываний системного таймера. Вызывает функцию `TKernel::system_timer()`.

## Портирование

Для портирования, как правило, достаточно определить для целевой платформы все вышеперечисленные макросы, типы и функции.

Наиболее "тонкая" и ответственная работа при портировании выпадает на реализацию ассемблерного кода и на функцию подготовки стекового кадра. Ряд моментов, на которые следует обратить особое внимание:

  * выяснить, какие используются соглашения о вызове функций у используемого компилятора, чтобы знать, какие регистры (или область стека) используются для передачи аргументов тех или иных типов;
  * определить особенности работы процессора в части сохранения адресов возвратов и статусных регистров при возникновении прерывания&nbsp;– это необходимо для понимания, как формируется стековый кадр на целевой аппаратной платформе, что, в свою очередь, важно для реализации функции (и обработчика прерываний) переключения контекстов, и функции формирования стекового кадра;
  * проверить схему кодирования экспортируемых/импортируемых имён ассемблера. В простейшем случае имена объектов и функций на С (и `"extern C"`[^ports-6] на С++) на ассемблере видны без изменений, но на некоторых платформах[^ports-7] к самому имени могут добавляться префиксы и/или суффиксы, что потребует ассемблерные функции именовать в соответствии с этой схемой, иначе линкер не сможет правильно выполнить связи.

[^ports-6]: Имена в С++ подвергаются специальному кодированию в целях поддержки перегрузки имён функций, а также для типобезопасного связывания, по какой причине получить к ним доступ на ассемблере задача трудновыполнимая. Поэтому имена функций, описанных в файлах, которые компилируются С++ компилятором и к которым необходим доступ из ассемблерного кода, должны быть объявлены в исходных файлах как `"extern C"`.

[^ports-7]: В частности, на Blackfin.

Весь ассемблерный код должен быть помещён в файл os_target_asm.ext, упомянутый выше. Определения макросов и типов, а также встраиваемых функций&nbsp;– в файл os_target.h. В файле os_target.cpp объявляются объекты типов, если необходимо,&nbsp;– например, `OS::TPrioMaskTable OS::PrioMaskTable`, а также определяются функция `TBaseProcess::init_stack_frame()` и обработчик прерывания системного таймера `system_timer_isr()`.

Вышеописанное является лишь общими сведениями, относящимися к порту ОС, при портировании возникает достаточно много нюансов, описание которых является весьма частным и выходит за рамки настоящего документа.

!!! tip "**СОВЕТ**"
 
    При создании нового порта имеет смысл взять за основу или в качестве примера один из существующих&nbsp;– это значительно облегчает процесс портирования. Какой именно выбрать из имеющихся портов, зависит от близости аппаратной и программной частей платформы, на которую осуществляется портирование.


## Запуск в составе рабочего проекта

Для повышения гибкости и эффективности использования часть платформеннозависимого кода, зависящая от частных особенностей того или иного проекта и конкретно используемого микроконтроллера, вынесена на уровень проекта. Сюда, как правило, относится выбор аппаратного таймера процессора, используемого в качестве системного, а также выбор прерывания переключения контекстов, если процессор не имеет специализированного программного прерывания.

Для конфигурирования порта проект должен содержать файлы:

  * scmRTOS_config.h;
  * scmRTOS_target_cfg.h;

scmRTOS_config.h содержит большинство конфигурационных макросов, задающих такие параметры, как количество процессов в программе, способ передачи управления, включение функции системного времени, разрешение использования пользовательских хуков, порядок нумерации значений приоритетов и т.д.

В scmRTOS_target_cfg.h размещён код управления ресурсами целевого процессора, выбранными для реализации системных функций&nbsp;– всё тот же системный таймер, прерывание переключения контекстов.

Содержимое обоих конфигурационных файлов подробно описано в документах, посвящённых конкретным портам.


