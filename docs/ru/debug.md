# Отладка

## Измерение потребления стека процессов

Существует вопрос, дать однозначный ответ на который в большинстве случаев оказывается довольно сложно: какой необходим объем оперативной памяти, выделенной под стек, чтобы её хватило для всех нужд программы и обеспечило правильную и безопасную её работу?

В случае программ, работающих без использования ОС, когда весь код выполняется с использованием одного-единственного стека, существуют средства оценки объёма памяти, выделенной под стек, необходимого для обеспечения правильной работы. Они основаны на построении дерева вызовов функций и известной информации о том, какой объём стека потребляет каждая функция. Эту работу может выполнить сам компилятор, поместив результаты в файл листинга после компиляции исходного файла. 

Для получения окончательного результата остаётся к результату самой потребляющей функции прибавить потребности в стеке самого потребляющего обработчика прерываний.

К сожалению, описанный метод даёт только приблизительную оценку, т.к.  компилятор не в состоянии точно построить дерево вызовов функций, возникающих на практике&nbsp;– в частности, косвенные вызовы функций, к которым относятся вызовы функций по указателю или вызовы виртуальных функций, не дают возможности учесть их вызов, т.к. на этапе компиляции ничего не известно о том, какая именно функция будет вызвана. В частных случаях, когда программист знает, какие функции могут быть вызваны косвенно, вычисление потребления стека может быть произведено вручную. Но этот способ неудобен&nbsp;– ведь это нужно делать при каждом сколько-нибудь значительном изменении программы, и он чреват ошибками.

В общем случае компилятор не обязан предоставлять такую информацию, а сторонние инструменты, выполняющие эту работу, также не способны обойти вышеописанные трудности, по какой причине не снискали себе популярности.

Всё это предъявляет разработчику программы выбор, какой указать размер стека. С одной стороны есть желание сэкономить ОЗУ, с другой - необходимо указать достаточный размер, чтобы не получить ошибки работы программы на этапе её выполнения, тем более, что ошибки, возникающие из-за неправильной работы с памятью, являются, как правило, весьма трудноуловимыми, т.к. их проявление всегда индивидуально и слабопредсказуемо. Поэтому на практике приходится указывать размер стека с некоторым запасом, что позволяет учесть ошибки в недооценке его размера. 

В случае использования операционной системы ситуация усугубляется в силу того, что стек в программе не один, а их количество равно количеству процессов, указанному при конфигурации ОС, что порождает больший дефицит ОЗУ и вынуждает разработчика ещё больше экономить память и указывать размеры стеков с меньшим запасом. 

Для решения вышеописанных проблем можно применить способ практического измерения объёмов потребления стека процессами. Эта возможность, как и другие возможности по отладке работы системы, включается в **scmRTOS** при конфигурации с помощью указания значения макроса `scmRTOS_DEGUG_ENABLE` равным&nbsp;1.

Суть метода состоит в том, чтобы на этапе подготовки стекового кадра заполнить пространство стека каким-либо заранее известным значением (паттерном), а при проверке результата просканировать область памяти, выделенную под стек процесса, начиная с конца, противоположного вершине стека (TOS), и найти место, где заканчивается заполнение паттерном. Количество ячеек, в которых паттерн не был перезаписан в процессе работы программы, показывает реальный запас по размеру стека процесса.

Заполнение стека паттерном производится в платформеннозависимой функции `init_stack_frame()` при разрешённом режиме отладки. Получить информацию о запасе по стеку1 процесса можно в любой момент, вызвав для объекта процесса функцию ```, возвращающую целое число, указывающее искомую величину. Исходя из этого, разработчик программы может откорректировать размеры стеков и тем самым исключить ошибки, возникающие из-за переполнения стеков.

## Работа с зависшими процессами

В процессе разработки нередко возникает характерная ситуация, когда по каким-то не ясным причинам программа работает неверно, и по косвенным признакам легко определить, что не работает тот или иной процесс. Обычно это случается, если процесс находится в ожидании какого-то сервиса (объекта межпроцессного взаимодействия), и, чтобы найти причину зависания, нужно определить, какой именно сервис стал причиной ожидания. 

Для определения сервиса, которого ждёт процесс, в режиме отладки **scmRTOS** включаются специальные средства&nbsp;– в частности, при переходе процесса в режим ожидания  запоминается адрес сервиса, который вызывал переход к ожиданию. При необходимости пользователь может вызвать функцию процесса `waiting_for()`, которая возвращает указатель на сервис, а зная этот адрес всегда можно по файлу отчёта линкера определить имя объекта сервиса.

## Профилировка работы процессов

Иногда бывает очень полезно узнать распределение нагрузки на процессы в программе. Эта информация позволяет оценить правильность работы алгоритмов программы и выявить ряд трудноуловимых логических ошибок. Для получения информации о загрузке процессов существует ряд методов определения относительного времени их активной работы, это называется профилировкой работы процессов.

В **scmRTOS** профилировка реализована в виде расширения и не входит в основной состав самой ОС. Профилировщик представляет собой класс-расширение, реализующий базовые функции по сбору информации об относительном времени работы и её обработку. Сбор этой информации может быть реализован двумя способами, имеющими свои достоинства и недостатки:
    
  * статистический;
  * измерительный.

### Статистический метод

Статистический метод не требует для своей работы никаких дополнительных ресурсов, кроме тех, которые предоставляет операционная система. Принцип его работы основан на сэмплировании через равные интервалы времени переменной ядра `CurProcPriority`, которая указывает, какой процесс является активным в данный момент времени. Сэмплирование удобно организовать, например, в обработчике системного таймера&nbsp;– чем больше процессорного времени занимает процесс, тем чаще он будет активным при сэмплировании. Недостатком такого метода является низкая точность, позволяющая получить лишь качественную картину происходящего. 

### Измерительный метод

Этот метод лишён главного недостатка профилировки статистическим методом&nbsp;– низкой точности определения времени загрузки процессов. Принцип работы измерительного метода основан на измерении времени работы процессов (отсюда и название). Для этого пользователь должен предоставить средства для измерения времени работы&nbsp;– это  может быть один из аппаратных таймеров МК или какие-либо другие средства&nbsp;– например, счётчик тактов процессора, если таковой имеется. Это цена за использование этого метода.

### Использование

Для использования профилировщика в пользовательском проекте необходимо определить функцию измерения времени и подключить профилировщик к проекту. Подробнее об этом см. [пример в приложении Профилировка процессов](profiler.md#profiler-profiler). 



## Имена процессов

С целью повышения удобства отладки предусмотрена возможность задавать строковые имена процессам. Имя задаётся обычным для языка С++ способом&nbsp;– через аргумент конструктора:

```cpp
MainProc main_proc("Main Process");
```

Этот строковый аргумент может быть описан всегда, но задействование  имени доступно только в  отладочной конфигурации.

Для доступа из пользовательской программы в классе `TBaseProcess` определена функция:
```cpp
const char *name();
```

Использование тривиально и ничем не отличается от работы с С-строками на языках С/С++. Пример вывода отладочной информации см.&nbsp;"Листинг&nbsp;1. Пример вывода отладочной информации".

```cpp
01    //-------------------------------------------------------------------------
02    void ProcProfiler::get_results()
03    {
04        print("------------------------------\n");
05        for(uint_fast8_t i = 0; i < OS::PROCESS_COUNT; ++i)
06        {
07        #if scmRTOS_DEBUG_ENABLE == 1
08            printf("#%d | CPU %5.2f | Slack %d | %s\n", i, 
09                   Profiler.get_result(i)/100.0, 
10                   OS::get_proc(i)->stack_slack(), 
11                   OS::get_proc(i)->name() );
12        #endif
13        }
14    }
15    //-------------------------------------------------------------------------
```
/// Caption
Листинг 1. Пример вывода отладочной информации
///

Приведённый код порождает следующий вывод:

```
------------------------------
#0 | CPU 82.52 | Slack 164 | Idle
#1 | CPU  0.00 | Slack 178 | Background
#2 | CPU  0.07 | Slack 387 | GUI
#3 | CPU  0.23 | Slack 259 | Video
#4 | CPU  0.00 | Slack 148 | BiasReg
#5 | CPU 17.09 | Slack 165 | RefFrame
#6 | CPU  0.03 | Slack 204 | TempMon
#7 | CPU  0.00 | Slack 151 | Terminal
#8 | CPU  0.01 | Slack 129 | Test
#9 | CPU  0.01 | Slack 301 | IBoard
```
