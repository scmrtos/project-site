# Процессы <span id="processes-processes"></span>

## Общие сведения и<br> внутреннее представление

### Процесс как таковой

Процесс в **scmRTOS**&nbsp;– это объект типа, производного от класса `OS::TBaseProcess`. Причина, по которой для каждого процесса требуется отдельный тип (ведь почему бы просто не сделать все процессы объектами типа `OS::TBaseProcess`), состоит в том, что процессы, несмотря на всю похожесть, всё-таки отличаются&nbsp;– у них разные размеры стеков и разные значения приоритетов (которые, не следует забывать, задаются статически).

Для определения типов процессов используется стандартное средство С++&nbsp;– шаблоны (templates), что позволяет получить "компактные" типы процессов, в которых содержатся все необходимые внутренности, включая и непосредственно стек процесса, который у всех процессов имеет разный размер и задаётся индивидуально.

### TBaseProcess

Основная функциональность процесса определена в базовом классе `OS::TBaseProcess`, от которого, как уже говорилось выше, и производятся сами процессы на основе шаблона `OS::process<>`. Такой метод использован для того, чтобы не множить одинаковый код в экземплярах[^processes-1] шаблона при их реализации. 

[^processes-1]: На жаргоне часто используют термин инстанс – instance.

Поэтому в самом шаблоне объявлено только то, что относится к различающимся в разных процессах сущностям – стеки и исполняемые функции процесса (`exec()`). Исходный код класса `OS::TBaseProcess` представлен[^processes-2]&nbsp;– см. "Листинг&nbsp;1.&nbsp;TBaseProcess".

[^processes-2]: На самом деле существует два варианта этого класса – обычный (он и показан) и с отдельным стеком для адресов возвратов, код которого тут не приводится для краткости, т.к. никаких принципиальных для понимания и изложения отличий в нём нет.

```cpp
01    class TBaseProcess                                                             
02    {                                                                              
03        friend class TKernel;                                                      
04        friend class TISRW;                                                        
05        friend class TISRW_SS;                                                     
06        friend class TKernelAgent;                                                 
07                                                                                   
08        friend void run();                                                         
09                                                                                   
10    public:                                                                        
11        TBaseProcess( stack_item_t * StackPoolEnd                                  
12                    , TPriority pr                                                 
13                    , void (*exec)()                                               
14                #if scmRTOS_DEBUG_ENABLE == 1                                      
15                    , stack_item_t * aStackPool                                    
16                    , const char   * name = 0                                      
17                #endif                                                             
18                    );                                                             
19    protected:                                                                     
20        INLINE void set_unready() { Kernel.set_process_unready(this->Priority); }  
21        void init_stack_frame( stack_item_t * StackPoolEnd                         
22                             , void (*exec)()                                      
23        #if scmRTOS_DEBUG_ENABLE == 1                                              
24                             , stack_item_t * StackPool                            
25        #endif                                                                     
26                             );                                                    
27    public:                                                                        
28                                                                                   
29    #else  // SEPARATE_RETURN_STACK                                                
30                                                                                   
31        TBaseProcess( stack_item_t* StackPoolEnd                                   
32                    , stack_item_t* RStack                                         
33                    , TPriority pr                                                 
34                    , void (*exec)()                                               
35                #if scmRTOS_DEBUG_ENABLE == 1                                      
36                    , stack_item_t * aStackPool                                    
37                    , stack_item_t * aRStackPool                                   
38                    , const char   * name = 0                                      
39                #endif                                                             
40                    );                                                             
41    protected:                                                                     
42        void init_stack_frame( stack_item_t * Stack                                
43                             , stack_item_t * RStack                               
44                             , void (*exec)()                                      
45        #if scmRTOS_DEBUG_ENABLE == 1                                              
46                             , stack_item_t * StackPool                            
47                             , stack_item_t * RStackPool                           
48        #endif                                                                     
49                             );                                                    
50                                                                                   
51        TPriority   priority() const { return Priority; }                          
52                                                                                   
53        static void sleep(timeout_t timeout = 0);                                  
54               void wake_up();                                                     
55               void force_wake_up();                                               
56        INLINE void start() { force_wake_up(); }                                   
57                                                                                   
58        INLINE bool is_sleeping() const;                                           
59        INLINE bool is_suspended() const;                                          
60                                                                                   
61    #if scmRTOS_DEBUG_ENABLE == 1                                                  
62      INLINE TService * waiting_for() const { return WaitingFor; }                 
63    public:                                                                        
64               size_t       stack_size()  const { return StackSize; }              
65               size_t       stack_slack() const;                                   
66               const char * name()        const { return Name; }                   
67    #endif // scmRTOS_DEBUG_ENABLE                                                 
68                                                                                   
69    #if scmRTOS_PROCESS_RESTART_ENABLE == 1                                        
70    protected:                                                                     
71               void reset_controls();                                              
72    #endif                                                                         
73                                                                                   
74        //-----------------------------------------------------                    
75        //                                                                         
76        //    Data members                                                         
77        //                                                                         
78    protected:                                                                     
79        stack_item_t *     StackPointer;                                           
80        volatile timeout_t Timeout;                                                
81        const TPriority    Priority;                                               
82    #if scmRTOS_DEBUG_ENABLE == 1                                                  
83        TService           * volatile WaitingFor;                                  
84        const stack_item_t * const    StackPool;                                   
85        const size_t                  StackSize; // as number of stack_item_t items
86        const char                  * Name;                                        
87    #endif // scmRTOS_DEBUG_ENABLE                                                 
88                                                                                   
89    #if scmRTOS_PROCESS_RESTART_ENABLE == 1                                        
90        volatile TProcessMap * WaitingProcessMap;                                  
91    #endif                                                                         
92                                                                                   
93    #if scmRTOS_SUSPENDED_PROCESS_ENABLE != 0                                      
94        static TProcessMap SuspendedProcessMap;                                    
95    #endif                                                                         
96    };                                                                             
```
/// Caption
Листинг 1. TBaseProcess
///

Несмотря на кажущуюся обширность определения этого класса, на самом деле он очень небольшой и простой. Его представление содержит всего три члена-данных&nbsp;– это указатель стека&nbsp;(79), счётчик тиков таймаута&nbsp;(80) и значение приоритета&nbsp;(81). Остальные члены-данные являются вспомогательными и присутствуют только при разрешении дополнительной функциональности&nbsp;– возможность прерывать работу процесса в любой момент с последующим перезапуском, а также средства отладки[^processes-3].

[^processes-3]: Это же касается и остального кода – большая часть определения класса занята описанием этих вспомогательных возможностей.

Интерфейс класса предоставляет следующие функции:

  * `sleep(timeout_t timeout = 0)`. Переводит процесс в состояние "спячки": значение аргумента присваивается внутренней переменной-счётчику таймаута, процесс удаляется из карты процессов, готовых к выполнению, и вызывается планировщик, который передаст управление следующему процессу из готовых к выполнению.
  * `wake_up()`. Выводит процесс из состояния "спячки". Процесс переводится в состояние готового к выполнению, только если он находился в состоянии ожидания с таймаутом события; при этом если этот процесс имеет приоритет выше текущего, то он сразу получает управление;
  * `force_wake_up()`. Выводит процесс из состояния "спячки". Процесс переводится в состояние готового к выполнению всегда. При этом если этот процесс имеет приоритет выше текущего, то он сразу получает управление. Этой функцией нужно пользоваться с особой осторожностью, т.к. некорректное использование может привести к неправильной (непредсказуемой) работе программы;
  * `is_sleeping()`. Проверяет, находится ли процесс в состоянии "спячки", т.е. в состоянии ожидания с таймаутом события;
  * `is_suspended()`. Проверяет, находится ли процесс в неактивном состоянии.

<span id="processes-process-stack"></span>

### Стек

Стек процесса&nbsp;– это некоторая непрерывная область оперативной памяти, используемая для хранения в ней данных процесса, а также сохранения контекста процесса и адресов возвратов из 
функций и прерываний.

В силу особенностей некоторых архитектур может быть использовано два раздельных стека – один для данных, другой для адресов возвратов. **scmRTOS** поддерживает такую возможность, позволяя размещать в каждом объекте-процессе две области ОЗУ – два стека, размер каждой из которых может быть указан индивидуально, исходя из требований прикладной задачи. Поддержка двух стеков включается с помощью макроса `SEPARATE_RETURN_STACK`, определяемого в файле os_target.h.

В защищённой секции объявлена очень важная функция `init_stack_frame()`, которая отвечает за формирование стекового кадра (stack frame). Дело в том, что старт исполняемых функций процессов происходит не так, как у обычных функций – исполняемые функции процесса не вызываются традиционным образом. Управление в них попадает тем же способом, что и при передаче управления между процессами (при переключении контекстов), поэтому старт исполняемой функции процесса происходит путём восстановления контекста данного процесса из стека с последующим переходом по адресу, содержащемуся в стеке на месте сохранённого адреса точки прерывания процесса.

Для того, чтобы такой старт стал возможным, требуется подготовить стек процесса соответствующим образом – проинициализировать ячейки памяти в стеке по заданным адресам  необходимыми значениями&nbsp;– т.е. содержимое стека процесса должно быть таким, как будто у процесса до этого отобрали управление (сохранив, естественно, контекст процесса). Конкретные действия по подготовке стекового кадра являются индивидуальными для каждой платформы, поэтому реализация функции `init_stack_frame()` вынесена на уровень портов операционной системы.

### Таймауты

Каждый процесс имеет специальную переменную `Timeout` для контроля за поведением процесса при ожиданиях событий с таймаутами или при "спячке". По сути эта переменная является счётчиком тиков системного таймера, и если её значение не равно нулю, то в обработчике прерывания системного таймера она декрементируется и сравнивается с нулём, при равенстве которому процесс-владелец этой переменной переводится в готовые к выполнению.

Таким образом, если процесс находится в "спячке" с таймаутом, т.е. переведён в неготовые к выполнению путём вызова функции `sleep(timeout)` с аргументом, отличным от нуля, то через промежуток времени, равный количеству тиков системного таймера[^processes-4], процесс будет "разбужен"[^processes-5] в обработчике прерываний системного таймера.

[^processes-4]: Строго говоря, не точно равный количеству тиков системного таймера, а с точностью до доли этого периода, которая зависит от момента вызова функции sleep по отношению к моменту возникновения прерывания системного таймера.

[^processes-5]: Т.е. переведён в готовые к выполнению.

Аналогичная ситуация будет и в случае вызова функции сервиса, которая предполагает ожидание события с таймаутом. В этом случае процесс будет переведён в готовые к выполнению либо при возникновении события, которое он ожидает, вызвав функцию сервиса, либо по истечению таймаута. Значение, возвращаемое функцией сервиса, однозначно указывает на источник "пробуждения" процесса, что позволяет пользовательской программе без проблем принять решение о дальнейших действиях в сложившейся ситуации.

### Приоритеты

Каждый процесс имеет также поле данных, содержащее приоритет процесса. Это поле является идентификатором процесса при манипуляции с процессами и их представлением, в частности, приоритет процесса&nbsp;– это индекс в таблице указателей на процессы, находящейся в составе ядра, куда записывается адрес каждого процесса при регистрации.

Приоритеты являются уникальными&nbsp;–  не может быть двух процессов с одинаковым приоритетом. Внутреннее представление приоритета&nbsp;– переменная целочисленного типа. Для безопасности использования при задании приоритетов предусмотрен специальный перечислимый тип `TPriority`.

<span id="processes-process-sleep"></span>

### Функция sleep()

Эта функция служит для перевода текущего процесса из активного состояния в неактивное. При этом если функция вызывается с аргументом, равным 0 (или без указания аргумента&nbsp;– функция объявлена с аргументом по умолчанию, равным 0), то процесс перейдёт в "спячку" до тех пор, пока его не разбудит, например, какой-либо другой процесс с помощью функции `TBaseProcess::force_wake_up()`. Если функция вызывается с аргументом, то процесс будет "спать" указанное количество тиков системного таймера, после чего будет "разбужен", т.е. приведён в состояние готового к выполнению. В этом случае "спячка" также может быть прервана другим процессом или обработчиком прерывания с помощью функций `TBaseProcess::wake_up()`, `TBaseProcess::force_wake_up()`.

----

## Создание и использование процесса

### Определение типа процесса

Для создания процесса нужно определить его тип и объявить объект этого типа.

Тип конкретного процесса описывается с помощью шаблона `OS::process`: см. "Листинг 2. Шаблон процесса".

```cpp
01    template<TPriority pr, size_t stk_size, TProcessStartState pss = pssRunning>     
02    class process : public TBaseProcess                                              
03    {                                                                                
04    public:                                                                          
05        INLINE_PROCESS_CTOR process( const char * name_str = 0, void (*func)() = 0 );
06                                                                                     
07        OS_PROCESS static void exec();                                               
08                                                                                     
09    #if scmRTOS_PROCESS_RESTART_ENABLE == 1                                          
10        INLINE void terminate( void (*func)() = 0 );                                 
11    #endif                                                                           
12                                                                                     
13    private:                                                                         
14        stack_item_t Stack[stk_size/sizeof(stack_item_t)];                           
15    };                                                                               
```
/// Caption
Листинг 2. Шаблон процесса
///

Как видно, к тому, что предоставляет базовый класс, добавлены две сущности:

  * стек процесса `Stack` с размером `stack_size`. Размер задаётся в байтах;
  * статическая функция `exec()`, являющаяся собственно той функцией, где размещается пользовательский код процесса.

### Объявление объекта процесса и его использование

Теперь достаточно объявить объект этого типа, который и будет собственно процессом, а также определить саму процессную функцию `exec()`.

```cpp

typedef OS::process<OS::prN, 100> Slon;

Slon slon;
```
где N – номер приоритета.

["Листинг 1. Исполняемая функция процесса из раздела Обзор операционной системы"](overview.md#overview-process-exec) иллюстрирует пример типовой исполняемой функции процесса.

Использование процесса состоит, главным образом, в написании пользовательского кода внутри функции процесса. При этом, как уже говорилось, следует соблюдать ряд простых правил:

  * необходимо позаботиться о том, чтобы поток управления программы не покидал исполняемой  функции процесса, в противном случае, в силу того, что эта функция не была вызвана обычным образом, при выходе из неё поток управления попадёт, грубо говоря, в неопределённые адреса, что повлечёт неопределённое поведение программы (хотя на практике поведение, как правило, вполне определённое&nbsp;– программа не работает!);
  * использовать функцию `TBaseProcess::wake_up()` нужно с осторожностью и внимательно, а `TBaseProcess::force_wake_up()`&nbsp;– с особой осторожностью, т.к. неаккуратное использование может привести к несвоевременной "побудке" спящего (отложенного) процесса, что может привести к коллизиям в межпроцессном взаимодействии.

<span id="processes-alternate-process-exec"></span>

#### Альтернативные способы объявления объекта процесса

##### Внешняя функция

При объявлении объекта процесса конструктору может быть передан указатель на стороннюю функцию вида `void func()`, которая в этом случае и будет являться исполняемой функцией процесса&nbsp;– см. "Листинг 3. Использование внешней функции в качестве исполняемой"

```cpp
01    OS_PROCESS void slon_exec();          
02                                          
03    Slon slon("Slon Process", &slon_exec);
04                                          
05    void slon_exec()                      
06    {                                     
07        ... // Declarations               
08        ... // Init process’s data        
09        for(;;)                           
10        {                                 
11            ... // process’s main loop    
12        }                                 
13    }                                     
```
/// Caption
Листинг 3. Использование внешней функции в качестве исполняемой
///

Плюсом этого варианта является более краткая запись без указания полной специализации шаблона (`template<>`) и пространства имён `OS`, которые необходимо использовать в случае функции-члена `process::exec`.

##### Исполняемая функция как аргумент конструктора процесса

Помимо обычной функции процессу можно передать безымянную функцию с требуемой сигнатурой&nbsp;– в С++ то реализуется с помощью механизма лямбда-функций, см. "Листинг 4. Лямбда-функция как исполняемая функция процесса".

```cpp
01    Slon slon("Slon Process", []      
02    {                                 
03        ... // Declarations           
04        ... // Init process’s data    
05        for(;;)                       
06        {                             
07            ... // process’s main loop
08        }                             
09    });                               
```
/// Caption
Листинг 4. Лямбда-функция как исполняемая функция процесса
///

Основным преимуществом этого способа является краткость описания&nbsp;– объект процесса и его исполняемая функция заключаются в одном выражении.

!!! warning "**ЗАМЕЧАНИЕ**"

    Обращая внимание на "Листинг 2. Шаблон процесса" (5), можно увидеть, что в случае использования сторонней функции в качестве исполняемой возникает необходимость и в указании имени процесса&nbsp;– таково требование синтаксиса языка программирования С++ (правила аргументов по-умолчанию).

    Имя процесса на практике используется только в целях отладки, поэтому оно не является необходимым, и может возникнуть вопрос о дополнительных накладных расходах в случае, когда имя не нужно. Однако реализация конструктора процесса такова, что накладных расходов не возникает&nbsp;– см "Листинг 5. Конструктор процесса".

    Из листинга видно, что имя процесса используется только когда разрешена отладка (04), в ином случае аргумент `const char *` оказывается безымянным и удаляется из кода, поэтому накладных расходов не возникает.

```cpp
01    template<TPriority pr, size_t stk_size, TProcessStartState pss>
02    OS::process<pr, stk_size, pss>::process( const char *          
03        #if scmRTOS_DEBUG_ENABLE == 1                              
04        name_str                                                   
05        #endif                                                     
06        , void (*func)()                                           
07        ) : TBaseProcess(&Stack[stk_size / sizeof(stack_item_t)]   
08                         , pr                                      
09                         , func ? func : exec                      
10                      #if scmRTOS_DEBUG_ENABLE == 1                
11                         , Stack                                   
12                         , name_str                                
13                      #endif                                       
14                         )                                         
15                                                                   
16    {                                                              
17        #if scmRTOS_SUSPENDED_PROCESS_ENABLE != 0                  
18        if ( pss == pssSuspended )                                 
19            clr_prio_tag(SuspendedProcessMap, get_prio_tag(pr));   
20        #endif                                                     
21    }                                                              
```
/// Caption
Листинг 5. Конструктор процесса
///


### Старт процесса  в неактивном состоянии

Иногда возникает необходимость в том, чтобы исполняемая функция процесса начинала работу не сразу после старта системы, а по определённому сигналу.  Например, есть несколько процессов, которые  должны начать свою работу только после инициализации/настройки какого-то (возможно, внешнего по  отношению к МК) оборудования, в противном случае могут возникнуть неприятные последствия из-за некорректных действий по отношению к такому оборудованию.

В этой ситуации потребуется некоторая диспетчеризация&nbsp;– процессы каким-то образом должны будут организовать свою работу так, чтобы не нарушить логику взаимодействия с этим оборудованием&nbsp;– например, все процессы, кроме одного (диспетчера) встают в самом начале в ожидание события (старта работы), которое будет им просигналено процессом-диспетчером. 

Процесс-диспетчер выполняет всю необходимую подготовительную работу и затем объявляет старт работы ожидающим процессам. Описанный подход потребует в каждом ожидающем старта процессе добавление соответствующего кода вручную, что загромождает код, добавляет работы и чревато ошибками. 

Кроме того, могут быть иные ситуации, когда требуется, чтобы процесс не  сразу начал свою работу. Для обеспечения описанной функциональности процесс имеет возможность стартовать в т.н.  неактивном состоянии. Такой процесс ничем не отличается от любого другого кроме того, что в карте процессов, готовых к выполнению (`ReadyProcessMap`), отсутствует его тег. 

Объявление такого процесса выглядит так[^processes-6]:
```cpp
typedef OS::process<OS::pr1, 300, OS::pssSuspended> Proc2;
...
Proc2 proc2;
```

В дальнейшем для старта работы этого процесса запускающий код должен будет вызвать функцию `force_wake_up()`:

```cpp
Proc2.force_wake_up();
```
[^processes-6]: Префикс ss в данном примере означает Start State

---

<span id="processes-process-restart"></span>

## Перезапуск процесса

Может возникнуть ситуация, когда необходимо прервать выполнение процесса извне и запустить его выполнение сначала. Например, некий процесс производит длительные вычисления, и случается так, что результаты этих вычислений оказываются в какой-то момент уже не нужны, а необходимо запустить новый цикл вычислений с новыми данными. Сделать это можно, завершив выполнение процесса с возможностью последующего его запуска с самого начала.

Для реализации вышесказанного ОС предоставляет пользователю две функции:

  * `OS::process::terminate(void (*func)() = 0)`;
  * `OS::TBaseProcess::start()`.

### Остановка выполнения процесса

Функция `terminate()` предназначена для вызова извне останавливаемого процесса. Внутри неё производится приведение всех связанных с данным процессом ресурсов в исходное состояние и процесс переводится в состояние неготового к выполнению. При этом, если процесс находился в ожидании какого-либо сервиса, тег процесса удаляется из карты ожидающих процессов этого сервиса.

Функция `terminate()` может получать в качестве аргумента указатель на функцию, которая будет использоваться в качестве исполняемой функции процесса при следующем запуске. Это даёт определённую гибкость при реализации функциональности программы &nbsp;– при каждом перезапуске можно указывать именно ту исполняемую функцию, которая необходима в текущем контексте программы.

!!! tip "**СОВЕТ**"

    Возможность указывать исполняемую функцию при перезапуске можно эффективно использовать для имитации удаления и создания процессов&nbsp;– некоторые библиотеки написаны таким образом, что требуют для своей работы динамического выделения ресурсов&nbsp;– в частности, создания процессов для выполнения задач с последующим удалением этих процессов. 

    **scmRTOS** не поддерживает динамическое создание и удаление процессов по причинам, [описанным ранее](overview.md#overview-avoid-dynamic-process), однако можно имитировать создание/удаление процессов, например, организовав пул процессов, из которого при необходимости можно использовать очередной процесс, указывая для него подходящую исполняемую функцию.

    Менять приоритеты процессов или размеры их стеков не получится&nbsp;– эти параметры задаются статически при конфигурировании ОС, но в многих случаях этого и не требуется, т.к. ресурсы, необходимые для выполнения задач, как правило, известны на этапе сборки.

### Запуск процесса

Запуск процесса производится раздельно&nbsp;– чтобы пользователь имел возможность сделать это в нужный с его точки зрения момент&nbsp;– и осуществляется с помощью функции `start()`, которая просто переводит процесс в готовые к выполнению. Процесс начнёт работу в соответствии с очерёдностью, определяемой его приоритетом и загрузкой ОС.

Для того, чтобы прерывание работы процесса и его старт работали правильно, эта функциональность должна быть разрешена при конфигурации&nbsp;– значение макроса `scmRTOS_PROCESS_RESTART_ENABLE` должно быть установлено в 1.
