# Ядро ОС <span id="kernel-kernel"></span>

## Общие сведения

Ядро операционной системы выполняет:
    
  * функции по организации процессов;
  * планирование (Scheduling) как на уровне процессов, так и на уровне прерываний;
  * поддержку межпроцессного взаимодействия;
  * поддержку системного времени (системный таймер);
  * поддержку расширений.

Основу ядра системы составляет класс `TKernel`, который включает в себя весь необходимый набор функций и данных. Объект этого класса существует, по понятным причинам, в единственном экземпляре. Почти всё его представление является закрытым и для доступа к нему со стороны некоторых частей ОС, которым требуется доступ к ресурсам этого класса, использован механизм "друзей" (friend) С++&nbsp;– функции и классы, которым предоставлен такой доступ, объявлены с ключевым словом `friend`.

Необходимо отметить, что под ядром в данном контексте понимается не только объект `TKernel`, но и средство расширения функциональных возможностей ОС, реализованное в виде класса `TKernelAgent`. Этот класс специально введён в состав операционной системы с целью предоставить базу для построения расширений. Забегая вперёд, можно отметить, что в **scmRTOS** все средства межпроцессного взаимодействия реализованы на основе такого расширения. Класс `TKernelAgent` объявлен "другом" (friend) класса `TKernel` и содержит минимально необходимый набор защищённых (protected) функций для предоставления потомкам доступа к ресурсам ядра. Расширения строятся путём наследования от класса `TKernelAgent`. Более подробно см. [Агент ядра и расширения](kernel.md#kernel-kernel-agent).

----

## Класс TKernel

### Состав

Класс `TKernel` содержит следующие члены-данные[^kernel-1]:

  * `CurProcPriority`. Переменная, содержащая номер приоритета текущего активного процесса. Служит для оперативного доступа к ресурсам текущего процесса, а также для манипуляций со статусом процесса (как по отношению к ядру, так и к средствам межпроцессного взаимодействия)[^kernel-2];
  * `ReadyProcessMap`. Карта процессов, готовых к выполнению. Содержит теги процессов, готовых к выполнению: каждый бит этой переменной соответствует тому или иному процессу, лог.&nbsp;1 указывает на то, что процесс готов к выполнению[^kernel-3], лог.&nbsp;0 – на то, что процесс не готов;
  * `ProcessTable`. Массив указателей на процессы, зарегистрированные в системе;
  * `ISR_NestCount`. переменная-счётчик входов в прерывания. При каждом входе она инкрементируется, при каждом выходе декрементируется;
  * `SysTickCount`. Переменная-счётчик тиков (переполнений) системного таймера. Присутствует только если эта функция разрешена (с помощью определения соответствующего макроса в конфигурационном файле);
  * `SchedProcPriority`\*. Переменная для хранения значения приоритета процесса, запланированного для передачи ему управления.

[^kernel-1]: Объекты, помеченные ‘\*’, присутствуют только в варианте с использованием передачи управления на основе программного прерывания.
[^kernel-2]: Возможно, идеологически более правильным было бы для этих целей использовать указатель на процесс, но анализ показал, что выигрыша по производительности тут не достигается, а размер указателя, как правило, больше, чем размер переменной целого типа для хранения приоритета.
[^kernel-3]: При этом процесс может быть активным, т.е. выполняться, а может быть и неактивным, т.е. находиться в ожидании получения управления&nbsp;– такая ситуация возникает, когда в системе есть другой готовый к выполнению процесс, у которого приоритет выше.

### Организация процессов

Функция по организации процессов сводится к регистрации созданных процессов. При этом в конструкторе каждого процесса вызывается функция ядра `register_process(TBaseProcess *`), которая помещает значение указателя на процесс, переданного в качестве аргумента, в таблицу ProcessTable (см. ниже) процессов системы. Местоположение этого указателя в таблице определяется в соответствии с приоритетом данного процесса, который фактически является индексом при обращении к таблице. Код функции регистрации процессов – см."Листинг&nbsp;1. Функция регистрации процессов".

```cpp
1    void OS::TKernel::register_process(OS::TBaseProcess * const p)
2    {
3        ProcessTable[p->Priority] = p;
4    }
```
/// Caption
Листинг 1. Функция регистрации процессов
///

Следующая системная функция – это собственно запуск ОС. Код функции запуска системы&nbsp;– см.&nbsp;"Листинг&nbsp;2. Функция запуска ОС".

```cpp
1    INLINE void OS::run()
2    {
3        stack_item_t *sp = Kernel.ProcessTable[pr0]->StackPointer;
4        os_start(sp);
5    }
```
/// Caption
Листинг 2. Функция запуска ОС
///

Как видно, действия предельно просты: из таблицы процессов извлекается указатель на стек самого приоритетного процесса (3) и производится собственно старт системы (4) путём запуска низкоуровневой функции `os_start()` с передачей ей в качестве аргумента извлечённого указателя на стек самого приоритетного процесса.

С этого момента начинается работа ОС в основном режиме, т.е. передача управления от процесса к процессу в соответствии с их приоритетами, событиями и пользовательской программой.

### Передача управления

Передача управления может происходить двумя способами:

  * процесс сам отдаёт управление, когда ему (пока) нечего больше делать, или в результате своей работы процесс должен войти в межпроцессное взаимодействие с другими процессами (захватить семафор взаимоисключения (`OS::TMutex`), или, "просигналив"" флаг события (`OS::TEventFlag`), сообщить об этом ядру, которое должно будет произвести (при необходимости) перепланирование процессов;
  * управление у процесса отбирается ядром в результате возникновения прерывания по какому-либо событию, и если это событие ожидал процесс с более высоким приоритетом, то управление будет  отдано этому процессу, а прерванный процесс будет ждать, пока тот, более приоритетный, не отработает своё задание и не отдаст управление[^kernel-4].

[^kernel-4]: Этот более приоритетный процесс может быть прерван, в свою очередь, еще более приоритетным процессом, и так до тех пор, пока дело не дойдет до самого приоритетного процесса, который может быть прерван (на время) только прерыванием, возврат из которого произойдет все равно в этот самый приоритетный процесс. Т.е. самый высокоприоритетный процесс не может быть прерван никаким другим процессом. При выходе из обработчика прерывания управление всегда передается самому приоритетному процессу из готовых к выполнению.

В первом случае перепланирование процессов производится синхронно по отношению к потоку выполнения программы – в коде планировщика. Во втором случае перепланировка производится асинхронно по возникновению события.

Собственно передачу управления можно организовать несколькими способами. Один из способов – прямая передача управления путём вызова из планировщика[^kernel-5] низкоуровневой[^kernel-6] функции переключателя контекста. Другой способ&nbsp;– передача управления путём активации специального программного прерывания, где и происходит переключение контекста. **scmRTOS**  поддерживает оба способа. И тот, и другой способы имеют свои достоинства и недостатки, которые будут подробно рассмотрены ниже.

[^kernel-5]: Или при выходе из обработчика прерывания&nbsp;– в зависимости от того, синхронная передача управления или асинхронная.

[^kernel-6]: Обычно реализуемой на ассемблере.

### Планировщик

Исходный код собственно планировщика представлен в функции `sched()`&nbsp;– см.&nbsp;"Листинг 3. Планировщик".

Здесь присутствуют два варианта – один для случая прямой передачи управления[^kernel-6.1], другой&nbsp;– для случая передачи управления с помощью программного прерывания.

[^kernel-6.1]: `scmRTOS_CONTEXT_SWITCH_SCHEME == 0`.

Нужно отметить, что вызов планировки с уровня основной программы производится с помощью функции scheduler(), которая вызывает собственно планировщик только, если вызов производится не из прерывания:

```cpp
INLINE void scheduler() { if(ISR_NestCount) return; else  sched(); }
```

При правильном использовании средств ОС такой ситуации не должно происходить, т.к. вызов планировки с уровня прерываний должен осуществляться через специализированные версии соответствующих функций (их имена имеют суффикс `_isr`), которые специально предназначены для работы с уровня прерываний.

Например, при необходимости просигналить из прерывания флаг события пользователь должен использовать функцию `signal_isr()`[^kernel-7] вместо ё. Но в случае использования последней фатальной ошибки при работе программы не произойдёт, просто планировщик реально не будет вызван, и, несмотря на возможно поступившее в прерывании событие, передачи управления не произойдёт, даже если её черёд в этот момент уже наступил. 

Передача управления произойдёт только при следующем вызове перепланировки, которая произойдёт при выполнении деструктора объекта типа `TISRW/TISRW_SS`. Таким образом, в функции `scheduler()` просто присутствует защита от краха работы программы при неаккуратном использовании сервисов, а также при использовании сервисов, в которых не предусмотрены соответствующие `_isr` функции&nbsp;– например, `channel::push()`.


[^kernel-7]: Все обработчики прерываний в программе, которые используют средства межпроцессного взаимодействия, должны содержать объявление объекта TISRW, размещённое до любого вызова функции-сервиса (т.е. где имеет место вызов планировщика). Этот объект должен быть объявлен до первого использования сервисов ОС.

```cpp
01    bool OS::TKernel::update_sched_prio()
02    {
03        uint_fast8_t NextPrty = highest_priority(ReadyProcessMap);
04    
05        if(NextPrty != CurProcPriority)
06        {
07            SchedProcPriority = NextPrty;
08            return true;
09        }
10    
11        return false;
12    }
    
13    #if scmRTOS_CONTEXT_SWITCH_SCHEME == 0
14    void TKernel::sched()
15    {
16        uint_fast8_t NextPrty = highest_priority(ReadyProcessMap);
17        if(NextPrty != CurProcPriority)
18        {
19        #if scmRTOS_CONTEXT_SWITCH_USER_HOOK_ENABLE == 1
20            context_switch_user_hook();
21        #endif
22    
23            stack_item_t*  Next_SP      = ProcessTable[NextPrty]->StackPointer;
24            stack_item_t** Curr_SP_addr = &(ProcessTable[CurProcPriority]->StackPointer);
25            CurProcPriority = NextPrty;
26            os_context_switcher(Curr_SP_addr, Next_SP);
27        }
28    }
29    #else
30    void TKernel::sched()
31    {
32        if(update_sched_prio())
33        {
34            raise_context_switch();
35            do
36            {
37                enable_context_switch();
38                DUMMY_INSTR();
39                disable_context_switch();
40            }
41            while(CurProcPriority != SchedProcPriority); // until context switch done
42        }
43    }
44    #endif // scmRTOS_CONTEXT_SWITCH_SCHEME
```
/// Caption
Листинг 3. Планировщик
///

#### Планировщик с прямой передачей управления

Все действия, выполняемые внутри планировщика, не должны быть прерываемы, поэтому код этой функции выполняется в критической секции. Но т.к. планировщик всегда вызывается при запрещённых прерываниях, то использовать в его коде критическую секцию нет необходимости.

Первым делом вычисляется приоритет самого высокоприоритетного процесса, готового к выполнению (путём анализа карты процессов, готовых к выполнению, `ReadyProcessMap`). 

Далее найденный приоритет сравнивается с текущим, и если они совпадают, то текущий процесс является как раз самым приоритетным из готовых  к выполнению и передачи управления другому процессу не требуется, т.е. поток управления остаётся в текущем процессе.

Если найденный приоритет не совпадает с текущим, то это означает, что появился более приоритетный по сравнению с текущим процесс, готовый к выполнению, и управление должно быть передано ему. Это достигается путём переключения контекстов процессов. Контекст текущего процесса сохраняется в стеке текущего процесса, а контекст следующего процесса извлекается из его стека. Эти действия платформеннозависимы и производятся в низкоуровневой функции (реализованной на ассемблере) `os_context_switcher()`, которая вызывается из планировщика (26).  Этой функции передаются в качестве аргументов два параметра:

  * адрес указателя стека текущего процесса, куда будет помещён сам указатель по окончании сохранения контекста текущего процесса (24);
  * указатель стека следующего процесса (23).

При реализации низкоуровневой функции-переключателя контекстов следует обратить внимание на соглашения о вызове функций и передаче параметров для данной платформы и компилятора.

#### Планировщик с программным прерыванием

В этом варианте планировщик весьма отличается от вышеописанного. Главное отличие&nbsp;– это то, что собственно переключение контекста происходит не путём непосредственного вызова функции-переключателя контекстов, а путём активации специального прерывания, в котором и происходит переключение контекстов. Такой способ таит в себе ряд нюансов и требует специальных мер по предотвращению нарушения целостности работы системы.

Основная трудность, возникающая при реализации этого способа передачи управления, состоит в том, что собственно код планировщика и код функции обработчика прерываний программного прерывания не являются строго непрерывными, "атомарными", между ними может возникнуть прерывание, которое также может инициировать перепланировку, что вызовет своего рода "наложение" результатов текущей перепланировки и нарушить целостность процесса передачи управления. Для того чтобы избежать этой коллизии, процесс "перепланировка-передача управления"" разбит на две "атомарные"" операции, которые можно безопасно разделять между собой. 

Первая операция – это, как и прежде, вычисление приоритета самого приоритетного процесса из готовых к выполнению&nbsp;– вызов функции `update_sched_prio()`(01)&nbsp;– и проверка необходимости перепланировки (32). Если такая необходимость имеется, то происходит фиксация значения приоритета следующего процесса в переменной `SchedProcPriority` (07) и активация программного прерывания переключения контекстов (34). Далее программа входит в цикл ожидания переключения контекстов (35).

Здесь кроется довольно тонкий момент. Ведь почему бы, например, было просто не сделать зону разрешённых прерываний в виде пары пустых (dummy) команд (чтобы аппаратура процессора успела осуществить собственно само прерывание)? Такая реализация таит в себе трудноуловимую ошибку, состоящую в следующем.

Если на момент разрешения переключения контекстов, которое в данной версии ОС реализуется путём общего разрешения прерываний (37), кроме программного прерывания были активированы одно или несколько других прерываний, причём приоритет некоторых из них выше, чем приоритет программного прерывания, то при этом, естественно, поток управления будет передан в обработчик соответствующего прерывания, по окончании которого будет произведён возврат в прерванную программу. Теперь в основной программе (т.е. внутри функции-планировщика) процессор может выполнить одну или несколько инструкций[^kernel-8], прежде чем может быть активировано следующее прерывание. 

[^kernel-8]: Это обычное свойство многих процессоров – после возврата из прерывания переход на обработчик следующего прерывания становится возможен не сразу в том же машинном цикле, а только лишь через один или более циклов.

При этом программа сможет дойти до кода, запрещающего переключение контекстов, что приведёт к тому, что прерывания глобально будут запрещены и, программное прерывание, где производится переключение контекста, выполнено не будет. Это означает, что далее поток управления останется в текущем процессе, в то время как должен был бы быть передан системе (и другим процессам) до тех пор, пока не возникнет событие, которое ожидает текущий процесс. Это есть не что иное как нарушение целостности системы и может приводить к самым разнообразным и труднопредсказуемым негативным последствиям. 

Очевидно, что такой ситуации возникать не должно, поэтому вместо нескольких пустых команд в зоне разрешённых прерываний используется цикл ожидания переключения контекстов. Т.е. сколько бы прерываний не стояло в очереди, пока реального переключения контекстов не произойдёт, поток управления программы дальше этого цикла не пойдёт.

Для обеспечения работоспособности описанного необходим критерий того, что перепланирование реально произошло. Таким критерием может выступать равенство переменных ядра `CurProcPriority` и `SchedProcPriority`. Эти переменные становятся равными друг другу (т.е. значение текущего приоритета становится равным запланированному значению) только после выполнения переключения контекстов. 

Как видно, никаких обновлений переменных, содержащих указатели стеков и значения текущего приоритета, тут нет. Все эти действия производятся позднее при непосредственном переключении контекстов путём вызова специальной функции ядра `os_context_switch_hook()`. 

Может возникнуть вопрос: зачем такие сложности? Чтобы ответить на этот вопрос, можно представить ситуацию: пусть в случае с переключением контекста с помощью программного прерывания реализация планировщика осталась такой же, как и в случае прямого вызова переключателя контекстов. Только вместо вызова:

```cpp
os_context_switcher(Curr_SP_addr, Next_SP); 
```

присутствует[^kernel-9]:

```cpp
raise_context_switch();
<wait_for_context_switch_done>;
```

[^kernel-9]: Под `<wait_for_context_switch_done>` предполагается весь код, обеспечивающий переключение контекстов, начиная от разрешения прерываний.

Теперь можно рассмотреть ситуацию, при которой в момент, когда разрешаются прерывания, на очереди стоит ещё одно или несколько прерываний, причём хотя бы одно из них более приоритетное, чем программное прерывание переключения контекстов, и в обработчике этого стоящего на очереди более приоритетного прерывания вызывается какая-либо из функций сервисов (средств межпроцессного взаимодействия). Что при этом получится?

При этом будет тоже вызван планировщик и произойдёт ещё одно перепланирование процессов. Но т.к. предыдущая перепланировка не была завершена&nbsp;– т.е. процессы реально не переключились, контексты не были физически сохранены и восстановлены, то новая перепланировка просто перезапишет переменные, содержащие указатели текущего и следующего процессов.

Кроме того, при определении необходимости в перепланировке будет использоваться значение `CurProcPriority`, которое фактически ошибочно, т.к. это значение приоритета следующего процесса, запланированного при прошлом вызове планировщика. Словом, произойдёт "наложение" планировок и нарушение целостности работы системы. 

Поэтому крайне важно, чтобы фактическое обновление значения `CurProcPriority` и переключение контекстов процессов были "атомарны"&nbsp;– неразрывны, не прерывались другим кодом, имеющим отношение к планировке процессов. В варианте с прямым вызовом переключателя контекстов это правило выполняется само по себе&nbsp;– вся работа планировщика происходит в критической секции, и прямо оттуда же и вызывается переключатель контекстов. 

В варианте с программным прерыванием планировка и переключение контекстов могут быть "разнесены"" во времени. Поэтому само переключение и изменение текущего приоритета происходят непосредственно во время выполнения обработчика программного прерывания[^kernel-10]. В нем сразу после сохранения контекста текущего процесса вызывается функция `os_context_switch_hook()` (где и производится непосредственно обновление значения `CurProcPriority`), а также указатель стека текущего процесса передаётся в `os_context_switch_hook()`, где он сохраняется в объекте текущего процесса, и извлекается и возвращается из функции указатель стека следующего процесса, необходимого для восстановления контекста этого процесса и последующей передачи ему управления.

Для того, чтобы не ухудшить характеристик быстродействия в обработчиках прерываний, существует специальная облегчённая встраиваемая версия планировщика, используемая некоторыми функциями-членами объектов-сервисов, оптимизированными для применения их в ISR. Код этой версии планировщика см.&nbsp;"Листинг 4.&nbsp;Вариант планировщика, оптимизированный для использования в ISR".

[^kernel-10]: Этот обработчик программного прерывания всегда реализуется на ассемблере и, кроме того, является платформеннозависимым, поэтому здесь его код не приводится.

```cpp
01    void OS::TKernel::sched_isr()
02    {
03        if(update_sched_prio())
04        {
05            raise_context_switch();
06        }
07    }
```
/// Caption
Листинг 4. Вариант планировщика, оптимизированный для использования в ISR
///

При выборе обработчика прерываний переключения контекстов следует отдавать предпочтение такому, у которого самый низкий приоритет (в случае приоритетного контроллера прерываний). Это позволит избежать лишних перепланировок и переключений контекстов в случае возникновения нескольких прерываний подряд.

### Плюсы и минусы способов передачи управления

Оба способа имеют свои достоинства и недостатки. Достоинства одного способа передачи управления являются недостатками другого и наоборот.

#### Прямая передача управления

К достоинствам прямой передачи управления относится, главным образом, то, что для реализации этого варианта не требуется наличия в целевом МК специального программного прерывания&nbsp;– далеко не во всех МК имеется такая аппаратная возможность. Вторым небольшим преимуществом является немного большее быстродействие по сравнению с вариантом программного прерывания, т.к. в последнем случае имеются дополнительные накладные расходы на активацию обработчика прерываний переключения контекстов, цикл ожидания переключения контекста и на вызов `os_context_switch_hook()`.

У варианта с прямой передачей управления существует серьёзный недостаток&nbsp;– при вызове планировщика из обработчика прерываний, компилятор вынужден сохранять "локальный контекст"" (scratch регистры процессора) из-за вызова невстраиваемой функции переключения контекста, а это накладные расходы, которые могут оказаться весьма немалыми по сравнению с остальным кодом ISR. 

Негативный момент тут состоит в том, что сохранение этих регистров может оказаться совершенно ненужным&nbsp;– ведь в той функции[^kernel-11], из-за которой они сохраняются, эти регистры не используются, поэтому если больше нет вызовов невстраиваемых функций, то код сохранения и восстановления этой группы регистров оказывается лишним.

[^kernel-11]: `os_context_switcher(stack_item_t **Curr_SP, stack_item_t *Next_SP)`

#### Передача управления на основе программного прерывания

Этот вариант лишён вышеописанного недостатка. Благодаря тому, что сам по себе ISR выполняется обычным образом и никакой перепланировки из него не делается, сохранение "локального контекста" также не производится, что значительно сокращает накладные расходы и повышает производительность системы. Чтобы не испортить картину вызовом невстраиваемой  функции-члена сервисного объекта межпроцессного взаимодействия рекомендуется пользоваться специальными, облечёнными, встраиваемыми версиями таких функций&nbsp;– об этом подробнее см. [раздел Средства межпроцессного взаимодействия](ipcs.md#ipcs-ipcs).

Главным недостатком  передачи управления с помощью программного прерывания является то, что не во всех аппаратных платформах имеется поддержка программного прерывания. В этом случае в качестве такого программного прерывания можно использовать одно из незанятых аппаратных прерываний. К сожалению, тут возникает некоторое отсутствие универсальности&nbsp;– заранее неизвестно, потребуется ли то или иное аппаратное прерывание в том или ином проекте, поэтому, если процессор специально не предоставляет подходящего прерывания, то выбор прерывания переключения контекстов передаётся (с уровня порта) на уровень проекта, и пользователь должен сам написать соответствующий код[^kernel-12].

[^kernel-12]: Дистрибутив **scmRTOS** предлагается ко вниманию в виде нескольких рабочих примеров использования, где весь этот код по организации и настройке программного прерывания присутствует, поэтому пользователю достаточно просто модифицировать этот код под потребности своего проекта или использовать как есть, если всё устраивает.

При использовании передачи управления с помощью программного прерывания в полной мере отражает ситуацию выражение: "Ядро отбирает управление у процессов".

#### Выводы

Учитывая вышеприведённый анализ достоинств и недостатков обоих способов передачи управления, общая рекомендация такова: если целевая платформа предоставляет подходящее прерывание для реализации переключения контекстов, то имеет смысл использовать этот вариант, особенно, если размер "локального контекста" достаточно велик. 

Использование прямой передачи управления оправдано реальной невозможностью использовать программное прерывание – например, когда такое прерывание целевая платформа не поддерживает, а использование аппаратного прерывания в качестве программного невозможно по тем или иным причинам, либо если характеристики быстродействия с этим вариантом передачи управления оказываются лучше в силу меньших накладных расходов на организацию переключения контекстов, а сохранение/восстановление "локального контекста" не несёт заметных накладных расходов в силу небольшого размера[^kernel-13] этого "контекста".

[^kernel-13]: Например, у **MSP430**/IAR "локальный контекст" составляет всего 4 регистра.

### Поддержка межпроцессного взаимодействия

Поддержка межпроцессного взаимодействия сводится к предоставлению ряда функций для контроля за состояниями процессов, а также в предоставлении доступа к механизмам перепланирования составным частям ОС – средствам межпроцессного взаимодействия. Более подробно об этом см. [раздел Средства межпроцессного взаимодействия](ipcs.md#ipcs-ipcs).

### Прерывания

#### Особенности использования с ОСРВ и реализация

Возникшее прерывание может быть источником события, которое нуждается в обработке тем или иным процессом, поэтому для минимизации (и детерминированности) времени отклика на событие используется (при необходимости) перепланирование процессов и передача управления наиболее приоритетному из готовых к выполнению. 

Код любого обработчика прерывания, который использует сервисы межпроцессного взаимодействия, должен на входе вызвать функцию `isr_enter()`, которая проинкрементирует переменную `ISR_NestCount`, и на выходе вызвать функцию `isr_exit()`, которая декрементирует `ISR_NestCount` и по её значению определяет уровень вложенности прерываний (в случае вложенных). Когда величина `ISR_NestCount` становится равной 0, это означает, что имеет место выход из обработчика прерывания в основную программу, и `isr_exit()` производит перепланирование (при необходимости) процессов путём вызова планировщика уровня прерываний.

Для упрощения использования и переносимости код, выполняемый на входе и выходе обработчиков прерываний, помещён соответственно в конструктор и деструктор специального класса-"обёртки" - `TISRW`, объект которого необходимо использовать в обработчике прерываний[^kernel-14]. Достаточно создать объект этого типа в коде обработчика прерываний, всё остальное компилятор сделает самостоятельно. Важно, чтобы объявление этого объекта было до первого использования функций сервисов.

[^kernel-14]: Упомянутые выше функции `isr_enter()` и  `isr_exit()` являются функциями-членами этого класса-"обёртки".

Следует иметь в виду, что если в обработчике прерываний имеет место вызов невстраиваемой функции, то компилятор сохранит "локальный контекст"&nbsp;– scratch[^kernel-15] регистры[^kernel-16]. Поэтому желательно избегать вызовов невстраиваемых функций из обработчиков прерываний, т.к. даже частичное сохранение контекста ухудшает характеристики и по скорости, и по коду[^kernel-17]. В связи с этим в текущей версии **scmRTOS** у некоторых объектов межпроцессного взаимодействия появились специальные дополнительные облегчённые функции для использования их в обработчиках прерываний. Функции эти являются встраиваемыми и используют облегчённую версию планировщика, которая также является встраиваемой. Подробнее об этом см.[раздел Средства межпроцессного взаимодействия](ipcs.md#ipcs-ipcs).

[^kernel-15]: Как правило, компилятор делит регистры процессора на две группы: scratch и preserved. Scratch регистры – это те, которые любая функция может использовать без предварительного сохранения. Preserved – регистры, значения которых в случае необходимости должны быть сохранены. Т.е. если функции потребовался регистр из группы preserved, то она должна сначала сохранить значение регистра, а после использования восстановить. В некоторых случаях preserved регистры называют local, в рассматриваемом контексте эти термины являются синонимами.

[^kernel-16]: На разных платформах доля (в общем количестве) этих регистров разная, например, при использовании EWAVR они занимают примерно половину от общего количества, при использовании EW430 -  меньше половины. В случае с VisualDSP++/**Blackfin** доля этих регистров велика, но на этой платформе и размеры стеков, как правило, достаточно большие, чтобы беспокоиться об этом.

[^kernel-17]: К сожалению, при использовании схемы с прямой передачей управления имеет место вызов невстраиваемой функции переключения контекстов, поэтому избежать накладных расходов на сохранение scratch регистров тут не удаётся.


#### Отдельный стек прерываний и вложенные прерывания

С прерываниями связан ещё один аспект использования ОСРВ вытесняющего типа. Как известно, при возникновении прерывания и передаче управления обработчику прерываний программа для работы использует стек прерванного процесса, который должен иметь размер, достаточный для удовлетворения потребностей как самого процесса, так и любого обработчика прерываний. Причём суммарных потребностей и по самому наихудшему варианту&nbsp;– например, выполнение кода процесса занимает пространство в стеке пиковое значение, и в этот момент возникает прерывание, обработчик которого тоже займёт часть стека. Размер стека должен быть таким, чтобы и в этом случае не возникло переполнения стека.

Очевидно, что вышеприведённые обстоятельства касаются всех процессов системы, и в случае наличия обработчиков прерываний, потребляющих значительный объем стекового пространства, размеры стеков всех процессов должны быть увеличены на определённую величину. Это приводит к повышенным накладным расходам по памяти. В случае же вложенных прерываний ситуация драматически усугубляется.

Для борьбы с этим эффектом применяется переключение указателя стека процессора на специализированный стек обработчиков прерываний, в случае возникновения последних. Таким образом, стеки процессов и стек прерываний оказываются "развязанными" относительно друг друга, и не возникает необходимости резервировать в стеке каждого процесса дополнительный объем памяти для обеспечения работы обработчиков прерываний.

Реализация отдельного стека прерываний выполняется на уровне порта. Некоторые процессоры имеют аппаратную поддержку переключения указателя стека на стек прерываний, это позволяет сделать использование этой возможности эффективным и безопасным[^kernel-18].

[^kernel-18]: В этом случае такой механизм является единственным реализованным в порте, и нет необходимости в отдельной реализации класса-"обёртки" `TISRW_SS`.

Вложенные прерывания&nbsp;– т.е. такие, обработчики которых могут прерывать не только работу основной программы, но и работу обработчиков прерываний, также имеют особенности применения, понимание которых важно для эффективного и безопасного использование этого механизма. В случае наличия у процессора контроллера прерываний с поддержкой многоуровневых прерываний с приоритетами, ситуация с использованием вложенных прерываний оказывается достаточно проста&nbsp;– возникновение опасных ситуаций при разрешении вложенных прерываний, как правило, учтено разработчиками процессора, и контроллер прерываний не позволяет случаться неприятностям, например, таким, как описано ниже. 

В случае, когда процессор имеет одноуровневую систему прерываний,  его реализация, как правило, такова, что при возникновении любого прерывания автоматически происходит общее запрещение прерываний. Это делается из соображений простоты и безопасности. Т.е. вложенные прерывания в такой системе не поддерживаются. Для того, чтобы разрешить вложенные прерывания, достаточно сделать общее разрешение прерываний, которое на процессорах с одноуровневой системой прерываний, как правило, выключается аппаратно при передаче управления обработчику прерываний. При этом возможна ситуация, когда уже выполняющийся обработчик прерываний будет вызван ещё раз&nbsp;– в случае, если "висит" запрос на обработку этого же прерывания[^kernel-19]. 

[^kernel-19]: Это может быть связано, например, со слишком частым возникновением событий, инициирующих прерывание, либо несброшенным флагом прерывания, который инициирует запрос на обработку прерывания.

Как правило, это является ошибочной ситуацией, которую необходимо избегать. Для того, чтобы не оказаться в таком положении, нужно чётко понимать, как особенности работы процессора, так и его "контекст"[^kernel-20], и весьма аккуратно писать код: перед общим разрешением прерываний запретить активизацию прерывания, обработчик которого уже выполняется, дабы избежать вторичного входа в этот же обработчик, а по окончании его работы не забыть вернуть управляющие ресурсы процессора в исходное состояние, которое было до манипуляций с разрешением вложенных прерываний.
Исходя из вышесказанного, можно дать следующую рекомендацию.

[^kernel-20]: Под "контекстом" в данном случае подразумевается логическое и смысловое окружение, в котором выполняется данная часть программы.

!!! error "**ПРЕДУПРЕЖДЕНИЕ**"

    Несмотря на видимое преимущество схемы с отдельным стеком прерываний, не рекомендуется использовать этот вариант на процессорах, которые не имеют аппаратных средств переключения указателя стека на стек прерываний.

    Это связано с дополнительными накладными расходами по переключению стека, плохой переносимостью&nbsp;– любые нестандартные расширения являются источником проблем, а также тем, что прямое вмешательство в процесс управления указателем стека может так или иначе вызвать коллизии с адресацией локальных объектов&nbsp;– например, компилятор, видя тело обработчика прерываний, выделяет[^kernel-21] память под локальные объекты в стеке. Причём делает это до вызова[^kernel-22] конструктора "обёртки"&nbsp;– таким образом, после переключения указателя стека на стек прерываний память, которая была выделена ранее, физически окажется в другом месте, и программа будет работать неправильно, а компилятор не сможет выявить эту ситуацию.

    Аналогично не рекомендуется использовать вложенные прерывания на процессорах, которые не  поддерживают такую возможность аппаратно. Такие прерывания требуют аккуратного использования и, как правило, дополнительного обслуживания&nbsp;– например, блокировки источника прерывания, чтобы при разрешении прерываний не возник ещё один вызов этого же обработчика. 

    [^kernel-21]: Точнее – резервирует. Обычно это делается путём модификации указателя стека.

    [^kernel-22]: Имеет на это полное право.  

Краткий вывод. Мотивация использования переключения указателя стека на стек прерываний коррелирует с использованием вложенных прерываний&nbsp;– ведь в случае вложенных прерываний потребление стека (в прерываниях) весьма возрастает, что накладывает&nbsp;– в случае отсутствия переключения на отдельный стек прерываний&nbsp;– дополнительные требования на размеры стеков процессов[^kernel-23].

!!! tip "**СОВЕТ**"

    В случае использования ОСРВ вытесняющего типа имеется возможность построить программу так, чтобы обработчики прерываний были только источниками событий, а всю обработку событий вынести на уровень процессов. Это позволяет сделать обработчики прерываний маленькими и быстрыми, что, в свою очередь, нивелирует необходимость и в переключении на стек прерываний, и в разрешении вложенных прерываний. В этом случае тело обработчика прерываний может быть соизмеримым с накладными расходами на переключение указателя стека на стек прерываний и разрешение вложенных прерываний. 

[^kernel-23]: Причём каждый процесс должен иметь такой размер стека, чтобы покрыть как потребности  самого процесса, так и потребление стека обработчиками прерываний, включая всю иерархию вложенности.

Именно так рекомендуется поступать в случае, когда процессор не поддерживает аппаратного переключения указателя стека на стек прерываний и не имеет контроллера прерываний с аппаратной поддержкой вложенных прерываний.

Следует заметить, что ОСРВ с приоритетным вытеснением является в некотором роде аналогом многоуровневого приоритетного контроллера прерываний, т.е. предоставляет возможность распределить выполнение кода в соответствии с важностью/срочностью. В связи с этим, в большинстве случаев не возникает необходимости размещать код обработки событий на уровне прерываний даже при наличии такого аппаратного контроллера, а использовать прерывания только как источники событий[^kernel-24], поместив их обработку на уровень процессов. Это рекомендуемый стиль построения программы.

[^kernel-24]: Сделав обработчики прерываний максимально простыми, короткими и быстрыми.

### Системный таймер

Системный таймер служит для формирования определённых временных интервалов, необходимых при работе процессов. Сюда относится поддержка таймаутов.

В качестве системного таймера используется обычно один из аппаратных таймеров процессора[^kernel-25].
Функциональность системного таймера реализуется в функции ядра `system_timer()`. Код этой функции&nbsp;– см.&nbsp;"Листинг 5.&nbsp;Системный таймер".

[^kernel-25]: Для этого подходит самый простой (без "наворотов") таймер. Единственное принципиальное требование к нему – он должен быть способен генерировать периодические прерывания через равные промежутки времени&nbsp;– например, прерывание по переполнению. Желательно, также, чтобы имелась возможность управлять величиной периода переполнения, чтобы подобрать подходящую частоту системных тиков.

```cpp
01    void OS::TKernel::system_timer()
02    {
03        SYS_TIMER_CRIT_SECT();
04    #if scmRTOS_SYSTEM_TICKS_ENABLE == 1
05        SysTickCount++;
06    #endif
07    
08    #if scmRTOS_PRIORITY_ORDER == 0
09        const uint_fast8_t BaseIndex = 0;
10    #else
11        const uint_fast8_t BaseIndex = 1;
12    #endif
13    
14        for(uint_fast8_t i = BaseIndex; i < (PROCESS_COUNT-1 + BaseIndex); i++)
15        {
16            TBaseProcess *p = ProcessTable[i];
17    
18            if(p->Timeout > 0)
19            {
20                if(--p->Timeout == 0)
21                {
22                    set_process_ready(p->Priority);
23                }
24            }
25        }
26    }
```
/// Caption
Листинг 5. Системный таймер
///

Как видно из исходного кода, действия очень простые:

  1. если разрешён счётчик тиков, то переменная счётчика инкрементируется (5);
  2. далее в цикле проверяются значения таймаутов всех зарегистрированных процессов, и если значение проверяемой переменной не равно 0[^kernel-26], тогда значение декрементируется и проверяется на 0. При равенстве  (после декремента) 0 (т.е. таймаут данного процесса истёк) данный процесс переводится в состояние готового к выполнению.

[^kernel-26]: Это означает, что процесс находится в ожидании с таймаутом.

Т.к. эта функция вызывается внутри обработчика прерываний от таймера, то при выходе в основную программу, как описано выше, управление будет передано наиболее приоритетному процессу из готовых к выполнению. Т.е. если таймаут какого-то (более приоритетного, чем прерванный) процесса истёк, то при выходе из прерывания он получит управление. Это реализуется с помощью планировщика (см. выше).

!!! info "**ЗАМЕЧАНИЕ**"

    В некоторых ОС есть рекомендации по установке величины длительности системного тика. Чаще всего называется диапазон 10[^kernel-28]&nbsp;– 100&nbsp;мс. Возможно, применительно к тем ОС это и правильно. Баланс тут определяется желанием получить наименьшие накладные расходы на прерывания от системного таймера и желанием получить большее разрешение по времени.

    Исходя из ориентации **scmRTOS** на малые МК, работающие в реальном времени, а также принимая во внимание тот факт, что накладные расходы (по времени выполнения)[^kernel-29] невелики, рекомендуемое значение системного тика равно 1&nbsp;–&nbsp;10&nbsp;мс.

    Здесь можно провести аналогию с другими областями, где малые объекты являются обычно более высокочастотными: например, сердцебиение у мыши намного чаще, чем у человека, а у человека чаще, чем у слона. При этом "поворотливость" как раз обратная. В технике есть аналогичная тенденция, поэтому разумно ожидать, что для малых процессоров период системного тика меньше, чем для больших – в больших системах и накладные расходы больше ввиду, как правило, большей загрузки более мощного процессора и, как следствие, меньшей его "поворотливости".

    [^kernel-28]: А как, например, организовать динамическую индикацию с таким периодом переключения разрядов, когда известно, что для комфортной работы необходимо, чтобы период переключения (при четырех разрядах) был не более 5 мс?

    [^kernel-29]: Ввиду малого количества процессов, а также простого и быстрого планировщика.

## Агент ядра и расширения <span id="kernel-kernel-agent"></span>

### Класс агента ядра

Класс `TKernelAgent` является специальным средством для предоставления доступа к ресурсам ядра при построении средств расширения функциональности операционной системы. 

Замысел в целом таков. Для создания того или иного расширения функциональных средств ОС требуется доступ к определённым ресурсам ядра&nbsp;– в частности, к переменной ядра, содержащей приоритет активного процесса, или к карте процессов системы. Предоставлять прямой доступ к этой части представления было бы не слишком разумно&nbsp;– это является нарушением модели безопасности объектного подхода[^kernel-30], что влечёт за собой такие негативные последствия, как неработоспособность программы при отсутствии должной дисциплины кодирования и/или потеря совместимости в случае изменения внутреннего представления ядра.

Поэтому для решения задачи доступа к ресурсам ядра предложен подход на основе специально созданного класса&nbsp;– агента ядра&nbsp;–  ограничивающего доступ через свой интерфейс, который является документированным. Всё это позволяет создавать расширения формализованным путём, что делает этот процесс проще и безопаснее. 

[^kernel-30]: Принципов инкапсуляции и абстракции.

Код класса агента ядра&nbsp;– см.&nbsp;"Листинг 3.6&nbsp;TKernelAgent".

```cpp
01    class TKernelAgent
02    {
03        INLINE static TBaseProcess * cur_proc() { return Kernel.ProcessTable[cur_proc_priority()]; }
04
05    protected:
06        TKernelAgent() { }
07        INLINE static uint_fast8_t const   & cur_proc_priority()       { return Kernel.CurProcPriority;  }
08        INLINE static volatile TProcessMap & ready_process_map()       { return Kernel.ReadyProcessMap;  }
09        INLINE static volatile timeout_t   & cur_proc_timeout()        { return cur_proc()->Timeout;     }
10        INLINE static void reschedule()                                { Kernel.scheduler();             }
11
12        INLINE static void set_process_ready   (const uint_fast8_t pr) { Kernel.set_process_ready(pr);   }
13         INLINE static void set_process_unready (const uint_fast8_t pr) { Kernel.set_process_unready(pr); }
14 
15     #if scmRTOS_DEBUG_ENABLE == 1
16         INLINE static TService * volatile & cur_proc_waiting_for()     { return cur_proc()->WaitingFor;  }
17     #endif
18 
19     #if scmRTOS_PROCESS_RESTART_ENABLE == 1
20         INLINE static volatile 
21         TProcessMap * & cur_proc_waiting_map()  { return cur_proc()->WaitingProcessMap; }
22     #endif
23     };                                                                                         
```                                
/// Caption
Листинг 6. TKernelAgent
///

Как видно из кода, определение класса таково, что невозможно создавать объекты этого класса. Это сделано сознательно, т.к. по замыслу TKernelAgent является основой для создания расширений: его главная функция - предоставить документированный интерфейс к ресурсам ядра. Поэтому всё использование этого кода становится возможным только в потомках этого класса, которые и являются собственно расширениями.

Пример использования `TKernelAgent` будет более подробно рассмотрен ниже при описании базового класса для создания средств межпроцессного взаимодействия `TService`.

Весь интерфейс класса представляет собой встраиваемые функции, что в большинстве случаев позволяет реализовать необходимые расширения без потери эффективности по сравнению с вариантом, когда доступ к ресурсам ядра производится непосредственно.

### Расширения

Вышеописанный класс агента ядра позволяет создавать дополнительные средства, расширяющие функциональные возможности ОС. Методология создания таких средств проста&nbsp;– достаточно объявить класс-наследник `TKernelAgent` и определить его содержимое. Такие классы называются расширениями операционной системы.

Размещение кода ядра ОС таково, что определения классов и определения ряда функций-членов классов разнесены в заголовочном файле **os_kernel.h**. Это даёт возможность написать пользовательский класс, которому доступны все определения типов ядра ОС, и в то же время определения этого пользовательского класса оказываются доступны в функциях-членах классов ядра&nbsp;– например, в планировщике и в функции системного таймера[^kernel-31].

[^kernel-31]: В пользовательских хуках.

Подключение расширений осуществляется с помощью конфигурационного файла **scmRTOS_extensions.h**, который включается в os_kernel.h между определениями типов ядра и их функций-членов. Это позволяет определение класса-расширения физически разместить в отдельном пользовательском заголовочном файле и подключить в проект посредством включения этого файла в scmRTOS_extensions.h. После этого расширение готово к использованию в соответствии со своим назначением.
