# Очередь заданий <span id="example-job-queue"></span>

## Введение 

Очередь заданий, которая будет рассмотрена в данном примере, представляет собой очередь сообщений на основе указателей на объекты-задания. Традиционно в ОС, написанных на языке программирования С, для реализации очередей сообщений используются указатели `void *` совместно с ручным преобразованием типов. Этот подход обусловлен имеющимися в наличие средствами языка С. Как уже было сказано,  такой подход признан неудовлетворительным по соображениям удобства и безопасности. Поэтому вместо него будет применён другой способ, который доступен благодаря использованию языка С++ и предоставляет ряд преимуществ. 

Во-первых, нет никакой необходимости в нетипизированных указателях&nbsp;– механизм шаблонов позволяет эффективно и безопасно использовать указатели на конкретные типы, что устраняет необходимость в ручном преобразовании типов. 

Во-вторых, имеется возможность ещё более повысить гибкость сообщений на указателях, введя возможность передавать не только данные, но и в некотором смысле "экспортировать" действия&nbsp;– т.е. сообщение не только служит для передачи данных, но и позволяют производить определённые действия на приёмном конце очереди. Это достаточно легко реализуется на основе иерархии полиморфных классов[^example-job-queue-1] сообщений. В данном примере и будет реализован упомянутый подход.

[^example-job-queue-1]: Для новичков в С++, но хорошо знакомых с языком С, можно привести аналогию по технической реализации. Суть полиморфизма состоит в выполнении разных действий при одном и том же описании. С++ поддерживает два вида полиморфизма&nbsp;– статический и динамический. Статический полиморфизм реализуется с помощью шаблонов (templates). Динамический&nbsp;– на основе виртуальных функций. Иерархия полиморфных классов строится с использованием динамического полиморфизма. 
Технически механизм виртуальных функций реализуется на базе таблиц указателей на функции. Поэтому на языке С тоже можно было бы реализовать аналогичный механизм&nbsp;– например, на основе структур с указателями на массивы указателей на функции. Но в случае с С придется много делать руками, что чревато ошибками, не очень наглядно и, вследствие этого, трудоёмко и неудобно. С++ здесь просто перекладывает всю рутинную работу на компилятор, избавляя пользователя от необходимости писать низкоуровневый код с таблицами указателей на функции, их правильной инициализацией и использованием.

Поскольку в очередь передаются только указатели, сами тела сообщений размещаются где-то в памяти. Способ размещения может быть различным – от статического до динамического, в данном примере этот момент опущен, т.к. в контексте рассмотрения он не важен и на практике пользователь сам решает, как ему поступить, исходя из требований задачи, имеющихся ресурсов, личных предпочтений и т.п.

В данном примере будет продемонстрирован метод делегирования выполнения заданий, реализованный на основе очереди сообщений.

## Постановка задачи

Разработка практически любой программы сводится к выполнению тех или иных действий, и эти действия по важности и приоритетности выполнения в общем случае различны, что и мотивирует использование операционных систем с приоритетными планировщиками. Нередко случается так, что в том или ином процессе при обработке событий возникает необходимость в выполнении некоего действия, требующего значительного процессорного времени[^example-job-queue-2] при отсутствии какой-то срочности в этом, т.е. это действие вполне может быть выполнено и в процессе с низким приоритетом. В этом случае разумно не тормозить текущий процесс выполнением этого действия, а перепоручить его выполнение другому процессу, имеющему низкий приоритет.

[^example-job-queue-2]: Например, обширные вычисления или обновление контекста экрана в программе с графическим интерфейсом пользователя.

К тому же, в программе вышеописанные ситуации могут иметь место неоднократно, и для решения этой проблемы логично создать специальный низкоприоритетный процесс, которому и перепоручать (делегировать) выполнение заданий из других процессов, выполнение которых не хочется или нельзя по условиям задачи производить в самих высокоприоритетных процессах. Механизм передачи заданий для выполнения удобно выполнить на основе полиморфных классов-заданий и сервиса `OS::channel`, используемого в качестве транспорта для передачи объектов-заданий.

## Реализация

Все задания, безотносительно к тому, какой процесс породил задание, что именно нужно сделать по заданию, имеют общее свойство&nbsp;– все они должны выполняться. Это позволяет использовать механизм, при котором запуск выполнения задания может быть произведён унифицированным способом, а реализация собственно задания сделана с помощью виртуальных функций. Для этого нужно определить абстрактный базовый класс, который задаёт интерфейс объектов-заданий:

```cpp
01    class Job                      
02    {                              
03    public:                        
04        virtual void execute() = 0;
05    };                             
```

Т.е. есть объект-задание, у которого определено его главное общее свойство&nbsp;– он может выполняться.

Для краткости изложения будет рассмотрено два разных типа заданий[^example-job-queue-3], ресурсоёмких в смысле времени выполнения: 

[^example-job-queue-3]: Очевидно, что при необходимости это количество можно можно легко увеличить.

 * вычислительное&nbsp;– например, вычисление полинома;
 * пересылка значительно объёма данных&nbsp;– обновление экранного буфера.

Для этого нужно определить два класса:

```cpp
01    class PolyVal : public Job      
02    {                               
03    public:                         
04        virtual void execute();     
05    };                              
06                                    
07    class UpdateScreen : public Job 
08    {                               
09    public:                         
10        virtual void execute();     
11    };                              
```

Объекты этих классов и будут представлять собой задания, выполнение которых передаётся в низкоприоритетный процесс. Подробнее см. "Листинг 1. Типы и объекты примера делегирования заданий".

```cpp
01    //---------------------------------------------------------------------
02    class Job // abstract job class
03    {
04    public:
05        virtual void execute() = 0;
06    };
07    //---------------------------------------------------------------------
08    class Polyval : public Job
09    {
10    public:
11        ... // constructors and the rest of the interface
12        virtual void execute();
13
14    private:
15        ... // representation: polynomial coefficients,
16        ... // arguments,
17        ... // result, etc.
18    };
19
20    //---------------------------------------------------------------------
21    class UpdateScreen : public Job
22    {
23    public:
24        ... // constructors and the rest of the interface
25        virtual void execute();
26
27    private:
28        ... // representation
29    };
30    //---------------------------------------------------------------------
31    typedef OS::process<OS::pr1, 200> HighPriorityProc1;
32    ...
33    typedef OS::process<OS::pr3, 200> HighPriorityProc2;
34    ...
35    typedef OS::process<OS::pr7, 200> BackgroundProc;
36
37    OS::channel<Job*, 4> job_queue;      // job queue with capacity for 4 elements
38    Polyval              poly_val;       // job object
39    UpdateScreen         update_screen;  // job object
40    ...
41    HighPriorityProc1    high_priority_proc1;
42    HighPriorityProc2    high_priority_proc2;
43    ...
44    BackgroundProc       background_proc;
45    //----------------------------------------------––-----------------------
```
/// Caption   
Листинг 1. Типы и объекты примера делегирования заданий
///

Абстрактный базовый класс Job задаёт интерфейс объектов-заданий, и объектов этого класса в программе быть не может. В данном случае интерфейс ограничен всего одной функцией `execute()`, что позволяет заданию выполняться[^example-job-queue-4]. Далее определены два конкретных класса-задания `Polyval` и `UpdateScreen`, которые уже нацелены на вполне чёткие цели: первый производит вычисление значения некоего полинома, второй обновляет экранный буфер.

[^example-job-queue-4]: При необходимости можно расширить интерфейс с помощью других чистых виртуальных функций.

Дальнейший код не являет собой ничего необычного&nbsp;– это штатный способ определения типов и объектов, принятый в языке программирования С++ и рекомендованный для использования совместно с **scmRTOS**. Следует заметить, что определения типов и объявления объектов могут быть размещены в разных файлах (заголовочных и исходных) так, как их удобнее использовать с точки зрения проекта. Конечно, для предотвращения возникновения ошибок при компиляции определения типов должны быть размещены так, чтобы быть доступными в точках объявления объектов,&nbsp;– это обыкновенное требование языков С/С++.

Ниже показан собственно код реализации делегирования заданий на основе очереди.

```cpp
01  //---------------------------------------------------------------------
02  template<> void HighPriorityProc1::exec()
03  {
04      const timeout_t DATA_UPDATE_PERIOD = 10;
05      for(;;)
06      {
07          ...
08          sleep(DATA_UPDATE_PERIOD);
09          ...                         // loading data into the job object
10          job_queue.push(&poly_val);  // placing the job into the queue
11      }
12  }
13  //---------------------------------------------------------------------
14  template<> void HighPriorityProc2::exec()
15  {
16      for(;;)
17      {
18          ...
19  
20          if(...) // screen element has changed
21          {
22              job_queue.push(&update_screen); // placing the job into the queue
23          }
24      }
25  }
26  //---------------------------------------------------------------------
27  template<> void BackgroundProc::exec()
28  {
29      for(;;)
30      {
31          Job *job;
32          job_queue.pop(job); // extracting a job from the queue
33          job->execute();     // executing the job
34      }
35  }
36  //---------------------------------------------------------------------
```
/// Caption
Листинг 2. Исполняемые функции процессов
///

В этом примере два высокоприоритетных процесса часть работы, относящейся к их области ответственности, перепоручают (делегируют) другому, низкоприоритетному процессу путём постановки заданий (с данными или без[^example-job-queue-5]) в очередь, которую он обрабатывает.

Сам этот низкоприоритетный (фоновый) процесс ничего не "знает" о том, что нужно делать по заданиям,&nbsp;– в его компетенции только запустить указанное задание, которое само имеет достаточно информации о том, что и как необходимо сделать. Важно то, что выполняться делегированное задание будет с нужным (низким в данном случае) приоритетом, не тормозя высокоприоритетные процессы[^example-job-queue-6].

[^example-job-queue-5]: Задание может быть снабжено какими-либо данными, которые постановщик задания передаёт внутри объекта-задания.

[^example-job-queue-6]: Не только сами процессы, которые перепоручают выполнение задание низкоприоритетному процессу, но и другие процессы, выполнение которых может блокироваться длительным выполнением заданий в высокоприоритетных процессах.

Очевидно, что в процессе-обработчике заданий можно легко организовать реализацию каких-либо действий, которые требуют периодического выполнения в фоне остальной программы. Для этого достаточно вызывать функцию `pop()` с таймаутом. По истечении таймаута процесс получит управление, и требуемые действия могут быть выполнены в этот момент. Как согласовать выполнение этих действий с выполнением заданий&nbsp;– это зависит от требований проекта и от решения, принимаемого пользователем.

Технические аспекты, на которые следует обратить внимание:

 * несмотря на то, что тип элементов очереди&nbsp;– это указатель на базовый класс `Job`, в очередь помещаются адреса объектов-заданий, которые являются производными от `Job`.  Это ключевой момент – на этом основан механизм работы виртуальных функций, являющийся центральным при реализации полиморфного поведения. При вызове `job->execute()` реально будет вызвана функция, принадлежащая классу, адрес объекта которого помещён в очередь;
 * сами объекты-задания в примере созданы статически. Это сделано для простоты&nbsp;– в данном случае способ создания этих объектов не важен, они могут быть размещены статически, они могут быть размещены в свободной памяти, важно, чтобы они имели нелокальное время жизни, т.е. могли существовать между вызовами функций. А факт существования активного задания состоит не в физическом существовании самого объекта-задания, а в помещении указателя с адресом объекта-задания в очередь.

В целом сам вышеописанный механизм достаточно прост, имеет низкие накладные расходы и позволяет гибко распределять программную нагрузку по приоритетам выполнения.

!!! info "**ЗАМЕЧАНИЕ**"

    Продемонстрированный выше механизм может быть применён не только для организации выполнения заданий с низким приоритетом, но и наоборот для выполнения их с высоким приоритетом&nbsp;– это актуально, если задание требует срочности выполнения, которую не обеспечивает приоритет того или иного процесса. Технически организация передачи заданий на выполнение точно такая же, как описано выше, с той лишь разницей, что процесс-обработчик заданий является не Background, а Foreground[^example-job-queue-7] процессом.

    [^example-job-queue-7]: По отношению к процессам, которые ставят задания в очередь.


### Семафоры взаимоисключения (mutex) и проблема блокировки высокоприоритетных процессов

При рассмотрении особенностей доступа к совместно используемым ресурсам из разных процессов через семафоры взаимоисключения была описана ситуация, решаемая [методом инверсии приоритетов](ipcs.md#ipcs-mutex-priority-inversion). 

Суть её сводилась к тому, что при определённых обстоятельствах низкоприоритетный процесс может опосредованно блокировать выполнение высокоприоритетного процесса. Для решения этой проблемы часто используют приём под названием "инверсия приоритетов", идея которого сводится к тому, что высокоприоритетный процесс, пытаясь захватить семафор взаимоисключения, в случае, если семафор уже захвачен низкоприоритетным процессом, не просто переходит в состояние ожидания обычным образом, а меняется приоритетами с тем низкоприоритетным процессом, который захватил семафор, до момента освобождения семафора.

Как уже было сказано ранее, этот метод не используется в **scmRTOS** ввиду наличия накладных расходов, сравнимых (или больших) с реализацией самого `TMutex`.

Для решения проблемы, упомянутой выше, можно предложить приём, описанный в данном примере. Только в качестве обработчика заданий использовать не низкоприоритетный процесс, а наоборот&nbsp;– высокоприоритетный. И программу организовать так, чтобы процессы, которые имеют доступ к совместно используемым ресурсам, эту работу не выполняли сами, а делегировали её в виде заданий высокоприоритетному процессу-обработчику.

В этой ситуации никаких коллизий с приоритетностью выполнения не возникает, а накладные расходы на передачу заданий в виде указателей на объекты незначительны.
