# Средства межпроцессного взаимодействия

## Введение

В **scmRTOS**, начиная с версии 4, разработан и применён принципиально иной, нежели в предыдущих версиях, механизм реализации средств межпроцессного взаимодействия. Ранее каждый класс сервиса был разработан индивидуально и никак не был связан с остальными, а для доступа к ресурсам ядра классы сервисов были объявлены как "друзья" ядра. Такой подход не позволял достичь повторного использования кода[^1] и не давал возможности расширять набор сервисов, по каким причинам решено было от него отказаться и спроектировать лишённый обоих недостатков вариант.

[^1]: Поскольку средства межпроцессного взаимодействия производят сходные действия по взаимодействию с ресурсами ядра, они содержат местами почти идентичный код.

В основе реализации лежит концепция расширения функциональности ОС путём определения классов-расширений на основе наследования от `TKernelAgent` (см. ["TKernelAgent и расширения"](kernel.md#kernel-agent)). 

Ключевым классом для построения средств межпроцессного взаимодействия является класс `TService`, в котором реализована общая функциональность всех классов-сервисов, и все они являются потомками `TService`. Это касается как штатного набора сервисов, входящих в дистрибутив ОС, так и тех, которые разработаны[^2] в качестве расширений стандартного ряда сервисов.

[^2]: Или могут быть разработаны пользователем под нужды своего проекта.

К средствам межпроцессного взаимодействия, входящим в состав scmRTOS, относятся:
    
  * `OS::TEventFlag`;
  * `OS::TMutex`;
  * `OS::message`;
  * `OS::channel`;

----

## TService

### Определение класса

Код базового класса для построения сервисных типов:

```cpp
01    class TService : protected TKernelAgent
02    {
03    protected:
04        TService() : TKernelAgent() { }
05
06        INLINE static TProcessMap  cur_proc_prio_tag()  { return get_prio_tag(cur_proc_priority()); }
07        INLINE static TProcessMap  highest_prio_tag(TProcessMap map)
08        {
09        #if scmRTOS_PRIORITY_ORDER == 0
10            return map & (~static_cast<unsigned>(map) + 1);   // Isolate rightmost 1-bit.
11        #else   // scmRTOS_PRIORITY_ORDER == 1
12            return get_prio_tag(highest_priority(map));
13        #endif
14        }
15
16        //----------------------------------------------------------------------
17        //
18        //   Base API
19        //
20
21        // add prio_tag proc to waiters map, reschedule
22        INLINE void suspend(TProcessMap volatile & waiters_map);
23
24        // returns false if waked-up by timeout or TBaseProcess::wake_up() | force_wake_up()
25        INLINE static bool is_timeouted(TProcessMap volatile & waiters_map);
26
27        // wake-up all processes from waiters map
28        // return false if no one process was waked-up
29               static bool resume_all     (TProcessMap volatile & waiters_map);
30        INLINE static bool resume_all_isr (TProcessMap volatile & waiters_map);
31
32        // wake-up next ready (most priority) process from waiters map if any
33        // return false if no one process was waked-up
34               static bool resume_next_ready     (TProcessMap volatile & waiters_map);
35        INLINE static bool resume_next_ready_isr (TProcessMap volatile & waiters_map);
36    };
```        
/// Caption
Листинг 1. TService
///

Как и класс-предок `TKernelAgent`, класс `TService` не позволяет создавать объекты своего типа: его назначение - предоставить базу для построения конкретных типов&nbsp;– средств межпроцессного взаимодействия. Интерфейс этого класса представляет собой набор функций, выражающих общие действия любого класса-сервиса в контексте передачи управления между процессами. Логически эти функции можно разделить на две части: основные и служебные. 

К служебным функциям относятся:

  1. `TService::cur_proc_prio_tag()`. Возвращает тег[^3], соответствующий текущему активному процессу. Этот тег активно используется основными функциями сервисов для фиксации идентификаторов[^4] процессов при постановке текущего процесса в состояние ожидания.
  2. `TService::highest_prio_tag()`. Возвращает тег наиболее приоритетного процесса из карты процессов, передаваемой в качестве аргумента. Используется главным образом для получения идентификатора (процесса) из зафиксированных в карте процессов объекта-сервиса, соответствующего процессу, который следует перевести в готовы к выполнению.

[^3]: Тег процесса технически является маской типа `TProcessMap`, в которой только один ненулевой бит. Позиция этого бита в маске соответствует приоритету процесса. Теги процессов служат для манипуляции с объектами `TProcessMap`, которые определяют готовность/неготовность процессов к выполнению, а также служат для фиксации тегов процессов.

[^4]: Наряду с номером приоритета процесса тег тоже может выполнять роль идентификатора процесса&nbsp;– между номером приоритета и тегом процесса существует однозначное соответствие. Каждый из типов идентификаторов имеет преимущества по эффективности использования в конкретной ситуации, поэтому оба типа интенсивно используются в коде ОС.

Основные функции:

  1. `TService::suspend()`. Переводит процесс в состояние неготовых  к выполнению с фиксацией идентификатора процесса в карте процессов сервиса и вызывает планировщик ОС. Эта функция является основой функций-членов сервисов, которые используются для ожидания события (`wait()`, `pop()`, `read()`) или действий, способных вызвать ожидание освобождения ресурса (`lock()`, `push()`, `write()`).
  2. `TService::is_timeouted()`. Функция возвращает false, если процесс был переведён в готовые к выполнению путём вызова функции-члена сервиса; если же процесс был переведён в готовые к выполнению по таймауту[^5] или принудительно с помощью функций-членов класса  `TBaseProccess` `wake_up()` и `force_wake_up()`, то функция возвращает `true`. Результат  этой функции используется для определения, дождался ли процесс события (освобождения ресурса), которого ждал, или нет.
  3. `TService::resume_all()`. Функция проверяет наличие процессов, "записанных" в карте процессов данного сервиса, но находящихся в состоянии неготовых к выполнению[^6]; если таковые имеются, то все они переводятся в состояние готовых к выполнению и вызывается планировщик. При этом функция возвращает true, в противном случае&nbsp;– `false`.
  4. `TService::resume_next_ready()`. Эта функция производит действия, сходные с вышеописанной `resume_all()`, но с той разницей, что при наличии ожидающих процессов, в готовые к выполнению из них переводятся не все, а только один&nbsp;– самый приоритетный.

[^5]: Иными словами, "разбужен"" в обработчике системного таймера.

[^6]: То есть процессов, состояние ожидания которых не было прервано по таймауту и/или принудительно с помощью `TBaseProccess::wake_up()` и `TBaseProccess::force_wake_up()`.

Для функций `resume_all()` и `resume_next_ready()` существуют версии, оптимизированные для использования внутри обработчиков прерываний&nbsp;– это `resume_all_isr()` и `resume_next_ready_isr()`. По назначению и смыслу они похожи на основные варианты[^7], главное отличие состоит в том, то из них не вызывается планировщик.

[^7]: Поэтому их полноценное описание не приводится.

### Использование

#### Предварительные замечания

Любой сервисный класс создаётся из `TService` путём наследования. Для   примера использования `TService` и создания сервисного класса на его основе будет рассмотрено одно из штатных средств межпроцессного взаимодействия&nbsp;– `TEventFlag`:

```cpp
class TEventFlag : public TService { ... }
```

Сам сервисный класс `TEventFlag` будет подробно описан ниже, в данный момент для целостности повествования следует отметить, что это средство межпроцессного взаимодействия служит для синхронизации работы процессов в соответствии с возникающими событиями. Основная идея использования: один процесс ждёт события, используя для этого функцию-член класса `TEventFlag::wait()`, другой процесс[^8] при  возникновении события, которое должно быть обработано в ожидающем процессе, сигналит флаг с помощью функции-члена `TEventFlag::signal()`.

[^8]: Или обработчик прерываний&nbsp;– смотря что является источником событий. Для обработчика прерываний существует специальная версия функции, которая сигналит флаг, но в контексте текущего описания это несущественно, поэтому этот нюанс опущен.

Учитывая вышесказанное, основное внимание при рассмотрении примера использования будет уделено именно этим двум функциям, т.к. именно они несут основную смысловую нагрузку сервисного класса[^9] и его разработка сводится, в основном, к разработке таких функций. 

[^9]: Остальное его представление носит вспомогательный характер и служит для придания законченности классу и улучшению его пользовательских характеристик.

#### Требования к функциям разрабатываемого класса

Требования к функции ожидания флага события. Функция должна проверять факт возникновения события на момент вызова функции и при отсутствии такового иметь возможность ожидать[^10] событие как безусловно, так и с условием до истечения таймаута. В случае возврата из функции по событию значение возврата true; в случае возврата из функции по таймауту значение возврата&nbsp;– `false`.

[^10]: Т.е. отдать управление ядру системы и остаться в пассивном ожидании.

Требования к функции посылки флага события. Функция должна перевести все процессы, ожидающие флага события, в состояние готовых к выполнению и передать управление планировщику.

#### Реализация

Внутри функции-члена `wait()`, см.&nbsp;"Листинг 2. Функция TEventFlag::wait()", первым делом производится проверка, не просигналено ли уже событие, и если это имеет место быть, то функция возвращает `true`. Если же событие не было просигналено (т.е. нужно его ожидать), то выполняются подготовительные действия&nbsp;– в частности, значение таймаута ожидания записывается в переменную `Timeout` текущего процесса и вызывается функция `suspend()`, определённая в базовом классе `TService`, которая записывает тег текущего процесса в карту процессов объекта-флага события, переданную функции `suspend()` в качестве аргумента, переводит данный процесс в неготовые к выполнению и отдаёт управление другим процессам путём вызова планировщика. 

При возврате из `suspend()`, что означает, что данный процесс был переведён в готовые к выполнению, производится проверка на предмет того, что явилось источником "пробуждения" данного процесса. Это выполняется с помощью вызова функции `is_timeouted()`, которая возвращает `false`, если процесс был "разбужен" через вызов функции `TEventFlag::signal()`&nbsp;– т.е. ожидаемое событие возникло (и таймаута не произошло), и `true`, если "пробуждение" процесса произошло по истечении таймаута, заданного аргументом `TEventFlag::wait()`, или принудительно. 

Такая логика работы функции-члена `TEventFlag::wait()` позволяет эффективно использовать её в пользовательском коде при организации работы процесса, синхронизированной с возникновением требуемых событий[^11]. При этом код реализации этой функции простой и прозрачный.

[^11]: В том числе и при отсутствии возникновения оных в заданный интервал времени.

```cpp
01    bool OS::TEventFlag::wait(timeout_t timeout)
02    {
03        TCritSect cs;
04   
05        if(Value)                         // if flag already signaled
06        {
07            Value = efOff;                // clear flag
08            return true;
09        }
10        else
11        {
12            cur_proc_timeout() = timeout;
13   
14            suspend(ProcessMap);
15   
16            if(is_timeouted(ProcessMap))
17                return false;            // waked up by timeout or by externals
18   
19            cur_proc_timeout() = 0;
20            return true;                 // otherwise waked up by signal() or signal_isr()
21        }
22    }
```
/// Caption
Листинг 2. Функция TEventFlag::wait()
///

```cpp
1    void OS::TEventFlag::signal()
2    {
3        TCritSect cs;
4        if(!resume_all(ProcessMap))   // if no one process was waiting for flag
5            Value = efOn;
6    }
```
/// Caption
Листинг 3. Функция TEventFlag::signal()
///

Код функции `TEventFlag::signal()`, см.&nbsp;"Листинг 3. Функция TEventFlag::signal()", предельно прост: внутри неё все ожидающие данного флага событий процессы переводятся в готовые к выполнению и производится перепланировка. Если таковых не оказалось, то внутренняя переменная флага событий efOn получает значение true, что означает, что событие произошло, но его никто пока не обработал. 

Подобным образом может быть спроектировано и определено любое средство межпроцессного взаимодействия. При его разработке необходимо лишь чётко представлять, что делают функции-члены класса TService, и использовать их к месту.

----

## OS::TEventFlag

При работе программы часто возникает необходимость в синхронизации между процессами. Т.е., например, один из процессов для выполнения своей работы должен дождаться события. При этом он может поступать разными способами: может просто в цикле опрашивать глобальный флаг или делать то же самое с некоторым периодом, т.е.  опросил&nbsp;–&nbsp;"упал в спячку" с таймаутом&nbsp;–&nbsp;"проснулся"&nbsp;–&nbsp;опросил и т.д. Первый способ плох тем, что при этом все процессы с меньшим приоритетом не получат управления, т.к. в силу своих более низких приоритетов они не смогут вытеснить процесс, опрашивающий в цикле глобальный флаг.

Второй способ тоже плох&nbsp;– период опроса получается достаточно большим (т.е. временное разрешение невысокое), и в процессе опроса процесс будет занимать процессор на переключение контекстов, хотя неизвестно, произошло ли событие.

Грамотным решением в этой ситуации является перевод процесса в состояние ожидания события и передача управления процессу только когда событие произойдёт.

Эта функциональность в scmRTOS реализуется с помощью объектов `OS::TEventFlag` (флаг события). Определение класса - см.&nbsp;"Листинг&nbsp;4. OS::TEventFlag".

```cpp
01    class TEventFlag : public TService                                            
02    {                                                                             
03    public:                                                                       
04        enum TValue { efOn = 1, efOff= 0 }; // prefix 'ef' means: "Event Flag"
05                                                                                  
06    public:                                                                       
07        INLINE TEventFlag(TValue init_val = efOff);
08                                                                                  
09               bool wait(timeout_t timeout = 0);                                  
10        INLINE void signal();                                                     
11        INLINE void clear()       { TCritSect cs; Value = efOff; }                
12        INLINE void signal_isr();                                                 
13        INLINE bool is_signaled() { TCritSect cs; return Value == efOn; }         
14                                                                                  
15    private:                                                                      
16        volatile TProcessMap ProcessMap;                                          
17        volatile TValue      Value;                                               
18    };                                                                            
```
/// Caption
Листинг 4. OS::TEventFlag
///

### Интерфейс

#### <u>wait</u>

###### Прототип

```cpp
bool OS::TEventFlag::wait(timeout_t timeout);
```

###### Описание

Ожидание события. При вызове функции `wait()` происходит следующее: проверяется, установлен ли флаг и если установлен, то флаг сбрасывается и функция возвращает `true`, т.е. событие на момент опроса уже произошло. Если флаг не установлен (т.е. событие ещё не произошло), то процесс переводится в состояние ожидания этого флага (события) и управление отдаётся ядру, которое, перепланировав процессы, запустит следующий.

Если вызов функции был произведён без аргументов (или с аргументом, равным 0), то процесс будет находиться в состоянии ожидания до тех пор, пока флаг события не будет "просигнален" другим процессом (с помощью функции `signal()`) или обработчиком прерывания (с помощью функции `signal_isr()`) или выведен из неактивного состояния с помощью функции `TBaseProcess::force_wake_up()` (в последнем случае нужно проявлять крайнюю осторожность).

Если функция `wait()` была вызвана без аргумента, то она всегда возвращает true. Если функция была вызвана с аргументом (целое число больше 0), который обозначает таймаут на ожидание в тиках системного таймера, то процесс будет ждать события, как и в случае вызова функции без аргумента, но, если в течение указанного периода флаг события не будет "просигнален", процесс будет "разбужен" таймером и функция вернёт `false`. Таким образом реализуются ожидание безусловное и ожидание с таймаутом;

#### <u>signal</u>

###### Прототип

```cpp
INLINE void OS::TEventFlag::signal();
```

###### Описание

Процесс, который желает сообщить посредством объекта `TEventFlag` другим процессам о том, что то или иное событие произошло, должен вызвать функцию `signal()`. При этом все процессы, ожидающие указанное событие, будут переведены в состояние готовых к выполнению, а управление получит самый приоритетный из них (остальные в порядке очерёдности приоритетов);

#### <u>signal from ISR</u>

###### Прототип

```cpp
INLINE void OS::TEventFlag::signal_isr();
```

###### Описание

Вариант вышеописанной функции, оптимизированный для использования в прерываниях. Функция является встраиваемой и использует специальную облегчённую встраиваемую версию планировщика. Этот вариант нельзя использовать вне кода обработчика прерываний;

#### <u></u>

###### Прототип

```cpp
INLINE void OS::TEventFlag::clear();
```

###### Описание

Очищать. Иногда для синхронизации нужно дождаться следующего события, а не обрабатывать уже произошедшее. В этом случае необходимо очистить флаг события и только после этого перейти к ожиданию. Для очистки служит функция `clear()`;

#### <u>check if signaled</u>

###### Прототип

```cpp
INLINE bool OS::TEventFlag::is_signaled();
```

###### Описание

Проверка состояния флага. Не всегда нужно ждать события, отдавая управление. Иногда по логике работы программы нужно только проверить факт, что событие произошло.

### Пример использования

Пример использования флага события – см.&nbsp;"Листинг&nbsp;5. Использование TEventFlag".

В этом примере процесс `Proc1` ждёт события с таймаутом, равным 10 тиков системного таймера (9). Второй процесс&nbsp;– `Proc2` при выполнении условия "сигналит" (27). При этом, если первый процесс был более приоритетным, то он сразу получит управление.

```cpp
01    OS::TEventFlag eflag;
02    ...
03    //----------------------------------------------------------------
04    template<> void Proc1::exec()
05    {
06        for(;;)
07        {
08            ...
09            if( eflag.wait(10) ) // wait event for 10 ticks
10            {
11                ...   // do something
12            }
13            else
14            {
15                ...   // do something else
16            }
17            ...
18        }
19    }
20    ...
21    //----------------------------------------------------------------
22    template<> void Proc2::exec()
23    {
24        for(;;)
25        {
26            ...
27            if( ... ) eflag.signal(); 
28            ...
29        }
30    }
31    //----------------------------------------------------------------
```
/// Caption
Листинг 5. Использование TEventFlag
///

!!! info "**ЗАМЕЧАНИЕ**"

    Когда произошло событие и какой-то процесс "сигналит" флаг, то все процессы, ожидавшие этот флаг, будут переведены в состояние готовых к выполнению. Другими словами, все, кто ждал, дождались. Управление они, конечно, получат в порядке очерёдности их приоритетов, но событие не будет пропущено ни одним процессом, успевшим встать на ожидание, независимо от приоритета процесса.

    Таким образом, флаг события *обладает свойством широковещательности*, что весьма полезно для организации оповещений и синхронизации многих процессов по одному событию. Разумеется, ничего не мешает использовать флаг событий по схеме "точка-точка", когда есть только один ожидающий события процесс.

----

## OS::TMutex

Семафор Mutex (от Mutual Exclusion&nbsp;– взаимное исключение), как видно из названия, служит для организации взаимного исключения доступа к нему. Т.е. в каждый момент времени не может быть более одного процесса, захватившего этот семафор. Если какой-либо процесс попытается захватить Mutex, который уже занят другим процессом, то пытающийся процесс будет ждать, пока семафор не освободится.

Основное применение семафоров Mutex&nbsp;– организация взаимного исключения при доступе к тому или иному ресурсу: например, некоторый статический массив с глобальной областью видимости[^12], и два процесса обмениваются друг с другом данными через этот массив. Во избежание ошибок при обмене нужно исключить возможность иметь доступ к массиву для одного процесса на протяжении промежутка времени, пока с массивом работает другой процесс.

Использовать для этого критическую секцию не лучший способ, т.к. при этом прерывания будут запрещены на все время обращения процесса к массиву, а это время может быть значительным, и в течение его система будет не способна реагировать на события. В этой ситуации как раз хорошо подходит семафор взаимоисключения: процесс, который планирует работать с совместно используемым ресурсом, должен сначала захватить семафор Mutex. После этого можно спокойно работать с ресурсом. 

По окончании работы нужно освободить семафор, чтобы другие процессы могли получить к нему доступ. Излишне напоминать, что так вести себя должны все процессы, работающие с общим ресурсом, т.е. производить обращение через семафор[^13]. 

[^12]: Чтобы к нему имелся доступ различных частей программы.

[^13]: Общее правило: все процессы, работающие с общим ресурсом, должны вести себя так, то есть производить обращение через семафор.

Эти же самые соображения в полной мере относятся к вызову нереентерабельной[^14] функции.

[^14]: Функция, которая использует в процессе своей работы объекты с нелокальным классом памяти, поэтому для предотвращения нарушения целостности работы программы такую функцию нельзя вызывать, если уже запущен экземпляр этой же функции.

!!! warning "**ПРЕДУПРЕЖДЕНИЕ**"

    При использовании семафоров взаимоисключения возможно возникновение ситуации, когда один процесс, захватив семафор и работая с соответствующим ресурсом, пытается получить доступ к другому ресурсу, доступ к которому также производится через захват другого семафора, и этот семафор уже захвачен другим процессом, который, в свою очередь, пытается получить  доступ к ресурсу, с которым уже работает первый процесс. При этом получается, что что оба процесса ждут, когда каждый из них освободит захваченный ресурс и до этого момента оба они не могут продолжить свою работу.

    Эта ситуация называется "смертельный замок"[^15], в англоязычной литературе она обозначается словом ”Deadlock”. Во избежание её программист должен внимательно следить за доступом к совместно используемым ресурсам. Хорошим правилом, позволяющим избежать вышеописанной ситуации, является захват не более одного семафора взаимоисключения одновременно. В любом случае, залог успеха тут базируется на внимательности и дисциплине разработчика программы.

[^15]: Иногда встречается перевод "смертельные объятия".

Для реализации бинарных семафоров этого типа в **scmRTOS** определён класс `OS::TMutex`, см.&nbsp;"Листинг 6. OS::TMutex".

```cpp
01    class TMutex : public TService
02    {
03    public:
04        INLINE TMutex() : ProcessMap(0), ValueTag(0) { }
05               void lock();
06               void unlock();
07               void unlock_isr();
08   
09        INLINE bool try_lock()        { TCritSect cs; if(ValueTag) return false;
10                                                      else lock(); return true; }
11        INLINE bool is_locked() const { TCritSect cs; return ValueTag != 0; }
12   
13    private:
14        volatile TProcessMap ProcessMap;
15        volatile TProcessMap ValueTag;
16   
17    };
```    
/// Caption
Листинг 6. OS::TMutex
///

Очевидно, что перед тем, как использовать, семафор нужно создать. В силу специфики применения семафор должен иметь класс памяти и область видимости такую же, как и обслуживаемый им ресурс, т.е. должен быть статическим объектом с глобальной областью видимости[^16].

[^16]: Хотя ничего не мешает размещать Mutex вне области видимости кода процесса и использовать указатель или ссылку как напрямую, так и через классы-«обёртки», позволяющие автоматизировать процесс разблокировки ресурса через автоматический вызов деструктора класса-"обёртки".


### Интерфейс

#### <u>lock</u>

###### Прототип

```cpp
void TMutex::lock();
```

###### Описание

Выполняет блокирующий захват: если до этого семафор не был захвачен другим процессом, то внутреннее значение будет переведено в состояние, соответствующее захваченному, и поток управления вернётся обратно  в  вызываемую функцию. Если семафор был захвачен, то процесс будет переведён в ожидание, пока семафор не будет освобождён, а управление отдано ядру.

#### <u>unlock</u>

###### Прототип

```cpp
void TMutex::unlock();
```

###### Описание

Функция переводит внутреннее значение в состояние, соответствующее освобождённому семафору, и проверяет, не ждёт ли какой-либо другой процесс этого семафора. Если ждёт, то управление будет отдано ядру, которое произведёт перепланирование процессов так, что, если ожидающий процесс был более приоритетным, он тут же получит управление. Если семафора ожидали несколько процессов, то управление получит самый приоритетный из них. Снять блокировку семафора может только тот процесс, который его заблокировал,&nbsp;– т.е. если выполнить описываемую функцию в процессе, который не заблокировал объект-мутекс, то никакого эффекта это не произведёт, объект останется в том же состоянии;

#### <u>unlock from ISR</u>

###### Прототип

```cpp
INLINE void TMutex::unlock_isr();
```

###### Описание

  Иногда возникает ситуация, когда мутекс блокируется в процессе, но работа с соответствующим защищаемым ресурсом производится в обработчике прерываний (при этом и запуск этой работы производится в процессе одновременно с захватом мутекса). 

  В этом случае удобно делать разблокировку прямо в обработчике прерываний по окончанию работы с ресурсом. Для этого в состав `TMutex` введена функция `unlock_isr()` разблокировки семафора непосредственно в прерывании;

#### <u>try to lock</u>

###### Прототип

```cpp
INLINE bool TMutex::try_lock();
```

###### Описание

  Неблокирюущий захват. Разница с `lock()` состоит в том, что захват будет иметь место только в случае, если семафор свободен. Например, требуется поработать с ресурсом, но кроме этого у процесса ещё есть много другой работы. Пытаясь захватить с помощью `lock()`, можно встать на ожидание и стоять там, пока семафор не освободится, хотя можно это время потратить на другую работу, если таковая имеется, а работу с совместно используемым ресурсом производить только тогда, когда доступ к нему не заблокирован.

  Такой подход может быть актуален в высокоприоритетном процессе: если семафор захвачен низкоприоритетным процессом, то при наличии работы в высокоприоритетном разумно не отдавать управление низкоприоритетному. И только когда уже делать будет больше нечего, имеет смысл пытаться захватить семафор обычным способом&nbsp;– с отдачей управления (ведь низкоприоритетный процесс тоже должен рано или поздно получить управление для того, чтобы закончить свои дела и освободить семафор).

  Учитывая вышеизложенное, пользоваться этой функцией нужно с осторожностью, т.к. это может привести к тому, что низкоприоритетный процесс вообще не получит управления из-за того, что его (управление) не отдаёт высокоприоритетный;


#### <u>try to lock with timeout</u>

###### Прототип

```cpp
OS::TMutex::try_lock(timeout_t timeout);
```

###### Описание

Блокирующая на указанный временной интервал версия предыдущей функции&nbsp;– пытается захватить семафор в течение указанного таймаута. Если захват произошёл, возвращает `true`, в противном случае&nbsp;– `false`;

#### <u>check if locked</u>

###### Прототип

```cpp
INLINE bool TMutex::is_locked()
```

###### Описание

Функция проверяет значение и возвращает `true`, если семафор захвачен, и `false` в противном случае. Иногда бывает удобно использовать семафор в качестве флага состояния, когда один процесс выставляет этот флаг (захватив семафор), а другие процессы проверяют его и выполняют действия в соответствии с состоянием того процесса.

### Пример использования

Пример использования – см.&nbsp;"Листинг&nbsp;7. Пример использования OS::TMutex"
```cpp
01    OS::TMutex Mutex;
02    byte buf[16];
03    ...
04    template<> void TSlon::exec()
05    {
06        for(;;)
07        {
08            ...                           // some code
09                                          //
10            Mutex.lock();                 // resource access lock
11            for(byte i = 0; i < 16; i++)  //   
12            {                             //
13                ...                       // do something with buf
14            }                             //
15            Mutex.unlock();               // resource access unlock
16                                          //
17            ...                           // some code
18        }
19    }
```
/// Caption
Листинг 7. Пример использования OS::TMutex
///

Для удобства использования семафора взаимоисключения можно применить уже не раз упоминавшуюся технику классов-"обёрток", которая в данном случае реализуется с помощью класса TMutexLocker, см. "Листинг&nbsp;8.  Класс-"обёртка" OS::TMutexLocker", входящего в дистрибутив ОС.

```cpp
01     template <typename Mutex>
02     class TScopedLock
03     {
04     public:
05         TScopedLock(Mutex& m): mx(m) { mx.lock(); }
06         ~TScopedLock() { mx.unlock(); }
07     private:
08         Mutex & mx;
09     };
10 
11     typedef TScopedLock<OS::TMutex> TMutexLocker;
```
/// Caption
Листинг 8. Класс-"обёртка" OS::TMutexLocker
///

Методология использования объектов этого класса ничем не отличается от методологии использования 
других классов-"обёрток"&nbsp;– `TCritSect`, `TISRW`.

<a name="mutex-priority-inversion"></a>
!!! tip "**ОБ ИНВЕРСИИ ПРИОРИТЕТОВ**"

    Следует сказать несколько слов о таком связанном с семафорами взаимоисключения механизме, как инверсия приоритетов.

    Сама идея инверсии приоритетов возникает из следующей ситуации. Например, в системе есть несколько процессов, и процессы с приоритетами N[^17] и N+n, где n>1, используют один и тот же ресурс, разделяя работу посредством семафора взаимоисключения. В какой-то момент процесс с приоритетом N+n захватил семафор и производит работу с общим ресурсом.

    Во время этого происходит событие, активизирующее процесс с приоритетом N, который пытается получить доступ к общему ресурсу, и, в попытке захватить семафор, переходит в состояние ожидания, в котором он будет находиться до тех пор, пока процесс с приоритетом N+n не разблокирует семафор. Задержка более приоритетного процесса в этой ситуации является вынужденной, т.к. невозможно отобрать управление у процесса с приоритетом N+n, не нарушив логики его работы и целостности доступа к общему ресурсу. Зная об этом, разработчик, как правило, старается минимизировать время работы с ресурсом, чтобы низкоприоритетный процесс не блокировал работу высокоприоритетного.

    Но в этой ситуации существует неприятность, состоящая в том, что если в вышеописанный момент вдруг активизируется процесс с приоритетом, например, N+1, то он вытеснит процесс с приоритетом N+n (т.к. n>1) и тем самым внесёт дополнительную задержку в ожидание более приоритетного процесса с приоритетом N. Ситуация усугубляется тем, что разработчик программы обычно не связывает работу процесса с приоритетом N+1 и манипуляции процессами с приоритетами N и N+n над общим ресурсом, поэтому может не ставить задачу оптимизации работы процесса с приоритетом N+1 в связи с этим, что может вообще блокировать работу процесса с приоритетом N на непредсказуемое время. Это является весьма нежелательной ситуацией.

    Чтобы избежать этого, применяется приём под названием "инверсия приоритетов". Суть его состоит в том, что если при попытке захвата семафора взаимоисключения высокоприоритетным процессом семафор уже был захвачен низкоприоритетным процессом, то производится временный обмен приоритетами до разблокировки семафора. При этом по факту получается, что низкоприоритетный процесс работает с приоритетом процесса, который пытался захватить семафор. В этом случае ситуация, описанная выше, когда низкоприоритетный процесс блокирует работу высокоприоритетного, оказывается невозможной.

[^17]: В данном примере предполагается, что приоритетность выполнения процессов связана с номерами приоритетов в обратной зависимости&nbsp;– т.е. процесс с приоритетом 0 является самым приоритетным, по мере возрастания номеров приоритетов приоритетность процессов уменьшается.

При всей стройности и элегантности метода инверсии приоритетов он не лишён недостатков. Главный&nbsp;–  его техническая реализация порождает накладные расходы, которые сравнимы или превышают затраты на реализацию функциональности собственно семафора взаимоисключения, и может получиться так, что переключение приоритетов процессов и всё связанное с этим&nbsp;– нужно учесть все элементы ОС, связанные с приоритетами процессов, задействованных при инверсии приоритетов,&nbsp;– замедлит работу системы до неприемлемого уровня. 

В связи с этим механизм инверсии приоритетов в текущей версии **scmRTOS** не используется, а для решения вышеописанной проблемы с блокировкой работы высокоприоритетного процесса низкоприоритетным предлагается механизм делегирования заданий, подробно рассмотренный в разделе Приложения ([Пример: очередь заданий](example-job-queue.md)), который представляет собой унифицированный метод перераспределения выполнения связанного по контексту программного кода в процессах с разными приоритетами.

----

## OS::message

`OS::message` представляет собой С++ шаблон для создания объектов, реализующих обмен между процессами путём передачи структурированных данных. `OS::message` похож на `OS::TEventFlag` и отличается главным образом тем, что кроме самого флага содержит ещё и объект произвольного типа, составляющий собственно тело сообщения.

Определение шаблона – см. "Листинг 9 OS::message".

Как видно из листинга, шаблон сообщения построен на основе класса `TBaseMessage`. Это сделано из соображений эффективности, чтобы общий код не дублировался в экземплярах шаблона&nbsp;– общий для всех сообщений код вынесен на уровень базового класса[^18].

[^18]: Этот же приём применён и при построении шаблона процесса: связка `class TBaseProcess`&nbsp;– `template process<>`.

```cpp
01    class TBaseMessage : public TService
02    {
03    public:
04        INLINE TBaseMessage() : ProcessMap(0), NonEmpty(false) { }
05   
06        bool wait  (timeout_t timeout = 0);
07        INLINE void send();
08        INLINE void send_isr();
09        INLINE bool is_non_empty() const { TCritSect cs; return NonEmpty;  }
10        INLINE void reset       ()       { TCritSect cs; NonEmpty = false; }
11   
12    private:
13        volatile TProcessMap ProcessMap;
14        volatile bool NonEmpty;
15    };
16   
17    template<typename T>
18    class message : public TBaseMessage
19    {
20    public:
21        INLINE message() : TBaseMessage()   { }
22        INLINE const T& operator= (const T& msg)
23        {
24            TCritSect cs;
25            *(const_cast<T*>(&Msg)) = msg; return const_cast<const T&>(Msg);
26        }
27        INLINE operator T() const
28        {
29            TCritSect cs;
30            return const_cast<const T&>(Msg);
31        }
32        INLINE void out(T& msg) { TCritSect cs; msg = const_cast<T&>(Msg); }
33   
34    private:
35        volatile T Msg;
36    };
```
/// Caption
Листинг 9. OS::message
///

### Интерфейс

#### <u>send</u>

###### Прототип

```cpp
INLINE void OS::TBaseMessage::send();
```

###### Описание

 Передача сообщение[^19]: операция сводится к переводу процессов, ожидающих сообщение, в состояние готовых к выполнению и вызову планировщика.

[^19]: Аналог функции `OS::TEventFlag::signal()`.

#### <u>send from ISR</u>

###### Прототип

```cpp
INLINE void OS::TBaseMessage::send_isr();
```

###### Описание

Вариант вышеописанной функции, оптимизированный для использования в прерываниях. Функция является встраиваемой и использует специальную облегчённую встраиваемую версию планировщика. *Этот вариант нельзя использовать вне кода обработчика прерываний*.

#### <u>wait</u>

###### Прототип

```cpp
bool OS::TBaseMessage::wait(timeout_t timeout);
```

###### Описание

Ожидание сообщения[^20]: функция проверяет, не пустое ли сообщение и если не пустое, то возвращает `true`, если пустое, то переводит текущий процесс из состояния готовых к выполнению в состояние ожидания этого сообщения.

[^20]: Аналог функции `OS::TEventFlag::wait()`.

Если при вызове не было указано аргумента либо аргумент был равен 0, то ожидание будет продолжаться до тех пор, пока какой-нибудь процесс не пошлёт сообщение или текущий процесс не будет "разбужен" с помощью функции `TBaseProcess::force_wake_up()`[^21].

[^21]: В последнем случае нужно проявлять крайнюю осторожность.

Если в качестве аргумента было указано целое число, которое является значением таймаута, выраженным в тиках системного таймера, то ожидание сообщения будет происходить с таймаутом, т.е. процесс будет "разбужен" в любом случае. Если это произойдёт до истечения таймаута, что означает приход сообщения до того, как таймаут истёк, то функция вернёт `true`. В противном случае, т.е. если таймаут истечёт до того, как сообщение будет послано, функция вернёт `false`.

#### <u>check if non-empty</u>

###### Прототип

```cpp
INLINE bool OS::TBaseMessage::is_non_empty(); 
```

###### Описание

Функция возвращает `true`, если сообщение было послано, и в `false` противном случае.

#### <u>reset</u>

###### Прототип

```cpp
INLINE OS::TBaseMessage::reset();
```

###### Описание

Функция сбрасывает сообщение, т.е. переводит  сообщение в состояние empty. При этом тело сообщения остаётся без изменений.

#### <u>write message contents</u>

###### Прототип

```cpp
template<typename T>
INLINE const T& OS::message<T>::operator= (const T& msg);
```

###### Описание

Записывает в объект-сообщение содержимое собственно сообщения. Штатный способ использования OS::message&nbsp;– это запись тела сообщения и посылка сообщения с помощью функции `TBaseMessage::send()`&nbsp;– см.&nbsp;"Листинг&nbsp;10. Использование OS::message".

#### <u>access message body by reference</u>

###### Прототип

```cpp
template<typename T>
INLINE OS::message<T>::operator T() const;
```

###### Описание

Возвращает константную ссылку на тело сообщения. Пользоваться этим средством следует с осторожностью, отдавая себе отчёт в том, что во время доступа к телу сообщения по ссылке оно может быть изменено в другом процессе (или обработчике прерывания). Поэтому рекомендуется для чтения тела сообщения использовать функцию `message::out()`.

#### <u>read message contents</u>

###### Прототип

```cpp
template<typename T>
INLINE OS::message<T>::out(T &msg);
```

###### Описание

Функция предназначена для чтения тела сообщения. Для достижения эффективности, чтобы не возникало лишнего копирования тела сообщения, в функцию передаётся ссылка внешний объект-тело сообщения, в который внутри функции копируется содержимое сообщения.

### Пример использования

```cpp
01    struct TMamont { ... }           //  data type for sending by message
02    
03    OS::message<Mamont> mamont_msg;  // OS::message object
04    
05    template<> void Proc1::exec()
06    {
07        for(;;)
08        {
09            Mamont mamont;
10            mamont_msg.wait();      // wait for message
11            mamont_msg.out(mamont); // read message contents to the external object 
12            ...                     // using the Mamont contents
13        }     
14    }
15    
16    template<> void Proc2::exec()
17    {
18        for(;;)
19        {
20            ...
21            Mamont m;           // create message content
22    
23            m...  =             // message body filling
24            mamont_msg = m;     // put the content to the OS::message object
25            mamont_msg.send();  // send the message
26            ...
27        }
28    }
```
/// Caption
Листинг 10. Использование OS::message
///

----

## OS::channel

`OS::channel` представляет собой С++ шаблон для создания объектов, реализующих кольцевые буфера[^22] для безопасной с точки зрения вытесняющей ОС передачи данных произвольного типа. OS::channel также, как и любое другое средство межпроцессного взаимодействия, решает задачи синхронизации. Тип конкретного кольцевого буфера задаётся на этапе инстанцирования[^23] шаблона в пользовательском коде. Шаблон канала `OS::channel` основан на шаблоне кольцевого буфера, определённого в библиотеке, входящей в дистрибутив **scmRTOS**:

```cpp
usr::ring_buffer<class T, uint16_t size, class S = uint8_t>`
```

[^22]: Функционально это FIFO, т.е. объект-очередь для передачи данных по схеме First Input&nbsp;– First Output.

[^23]: Создания экземпляра класса.

Построение каналов на основе шаблонов C++ дают эффективное средство для построения очередей сообщений произвольних типов. Причём в отличие от опасного, не наглядного и не гибкого способа организации очередей сообщений на основе указателя `void *`, очередь `OS::channel` предоставляет:
    
  * безопасность на основе статического контроля типов как при создании очереди-канала, так и при записи в неё данных и чтении их оттуда;
  * простоту использования&nbsp;– не нужно выполнять ручное преобразование типов, сопряжённое с необходимостью держать в голове лишнюю информацию о реальных типах данных, передаваемых через канал с целью правильного их использования;
  * значительно большую гибкость использования&nbsp;– объектами очереди могут быть любые типы, а не только указатели. 

По поводу последнего пункта следует сказать несколько слов: недостаток указателей `void *` в качестве основы для передачи сообщений состоит, в частности, в том, что пользователь должен где-то выделить память под сами сообщения. Это дополнительная работа, и целевой объект получается распределённым&nbsp;– очередь в одном месте, а собственно содержимое элементов очереди в другом. 

Главными достоинствами механизма сообщений на указателях является высокая эффективность работы при больших размерах тел сообщений и возможность передачи разноформатных сообщений. Но если, например, сообщения небольшого размера&nbsp;– в пределах нескольких байт&nbsp;– и все имеют одинаковый формат, то нет никакой необходимости в указателях, гораздо проще создать очередь из требуемого количества таких сообщений, и все. При этом, как уже говорилось, не нужно выделять память под сами тела сообщений – поскольку сообщения целиком помещаются в очередь-канал, память под них в этом случае будет автоматически выделена непосредственно при создании канала компилятором.

Определение шаблона канала – см.&nbsp;"Листинг&nbsp;11. Определение шаблона OS::channel".

```cpp
01    template<typename T, uint16_t Size, typename S = uint8_t>                         
02    class channel : public TService                                                   
03    {                                                                                 
04    public:                                                                           
05        INLINE channel() : ProducersProcessMap(0)                                     
06                         , ConsumersProcessMap(0)                                     
07                         , pool()                                                     
08        {                                                                             
09        }                                                                             
10                                                                                      
11        //----------------------------------------------------------------            
12        //                                                                            
13        //    Data transfer functions                                                 
14        //                                                                            
15        void write(const T* data, const S cnt);                                       
16        bool read (T* const data, const S cnt, timeout_t timeout = 0);                
17                                                                                      
18        void push      (const T& item);                                               
19        void push_front(const T& item);                                               
20                                                                                      
21        bool pop     (T& item, timeout_t timeout = 0);                                
22        bool pop_back(T& item, timeout_t timeout = 0);                                
23                                                                                       
24        //----------------------------------------------------------------            
25        //                                                                            
26        //    Service functions                                                       
27        //                                                                            
28        INLINE S get_count()     const; 
29        INLINE S get_free_size() const;
30        void flush();                                                                 
31                                                                                      
32    private:                                                                          
33        volatile TProcessMap ProducersProcessMap;                                     
34        volatile TProcessMap ConsumersProcessMap;                                     
35        usr::ring_buffer<T, Size, S> pool;                                            
36    };                                                                                
```
/// Caption
Листинг 11. Определение шаблона OS::channel
///

Используется `OS::channel` следующим образом: сначала нужно определить тип объектов, которые будут передаваться через канал, затем определить тип канала либо создать объект-канал. Например, пусть данные, передаваемые через канал, представляют собой структуру:

```cpp
struct Data
{
    int   a;
    char *p;
};
```

Теперь можно создать объект-канал путём инстанцирования шаблона `OS::channel`:

```cpp
OS::channel<Data, 8> data_queue;
```

Этот код объявляет объект-канал `data_queue` для передачи объектов типа `Data`, ёмкость канала&nbsp;– 8 объектов. Теперь можно использовать канал для передачи.

`OS::channel` предоставляет возможность записывать данные не только в конец очереди, но и в начало; читать данные не только из начала очереди, но и из конца. При чтении также имеется возможность указать величину таймаута.

Для действий над объектом-каналом предоставляется следующий интерфейс:

### Интерфейс

#### <u>push</u>

###### Прототип

```cpp
template<typename T, uint16_t Size, typename S>
void OS::channel<T, Size, S>::push(const T &item);
```

###### Описание

Функция один элемент в конец очереди[^24]. Если на момент записи в канале было место, то элемент записывается в очередь и вызывается планировщик. Если места не было, то процесс переходит в состояние ожидания до тех пор, пока в канале не появится место. Когда место появится, элемент будет записан с последующим вызовом планировщика.

#### <u>push front</u>

###### Прототип

```cpp
template<typename T, uint16_t Size, typename S>
void OS::channel<T, Size, S>::push_front(const T &item);
```

###### Описание

Записать элемент в начало очереди, в остальном логика работы точно такая же, как в случае `channel::push()`.

#### <u>pop</u>

###### Прототип

```cpp
template<typename T, uint16_t Size, typename S>
bool OS::channel<T, Size, S>::pop(T &item, timeout_t timeout);
```

###### Описание

Извлекает один элемент из начала очереди, если канал не был пуст. Если канал был пуст, то процесс переходит в состояние ожидания до тех пор, пока в нем не появятся данные, либо до истечения таймаута, если таймаут был указан[^25]. 

В случае вызова с таймаутом, если данные поступили до истечения таймаута, функция возвращает `true`, в противном случае `false`. Если вызов был без таймаута, функция всегда возвращает `true`, за исключением пробуждения по `OS::TBaseProcess::wake_up()`, `OS::TBaseProcess::force_wake_up()`.

Во всех случаях при извлечении элемента вызывается планировщик.

Следует обратить внимание на тот факт, что при вызове этой функции данные, извлечённые из канала, передаются не путём копирования при возврате функции, а через передачу объекта по ссылке. Это обусловлено тем, что значение возврата занято для передачи результата таймаута.

#### <u>pop back</u>

###### Прототип

```cpp
template<typename T, uint16_t Size, typename S>
bool OS::channel<T, Size, S>::pop_back(T &item, timeout_t timeout);
```

###### Описание

 Извлекает один элемент из конца очередиия, если канал не был пуст.Вся функциональность ровно такая же, как и в случае с `channel::pop()`ж

#### <u>write</u>

###### Прототип

```cpp
template<typename T, uint16_t Size, typename S>
void OS::channel<T, Size, S>::write(const T *data, const S count);
```

###### Описание

Записывает в конец очереди несколько элементов из памяти по адресу. Фактически это то же самое, что и записать один элемент в конец очереди (push), только записывается не один элемент, а указанное количество, и в случае ожидания, оно продолжается до тех пор, пока в канале не появится достаточно места.

#### <u>write inside ISR</u>

###### Прототип

```cpp
template<typename T, uint16_t Size, typename S>
S OS::channel<T, Size, S>::write_isr(const T *data, const S count);
```

###### Описание

Специальная версия при использовании внутри обработчиков прерываний. Функция записывает столько элементов, сколько позволяет свободное место в канале (но не более указанного количества), возвращает количество записанных элементов. При этом процессы, ожидавшие данных из канала, переводятся в состояние готовых к выполнению. 

Вызов неблокирующий. Планировщик не вызывается.

#### <u>read</u>

###### Прототип

```cpp
template<typename T, uint16_t Size, typename S>
bool OS::channel<T, Size, S>::read(T *const data, const S count, timeout_t timeout);
```

###### Описание

Извлекает из канала несколько элементов.  То же самое, что и `channel::pop()`, только извлекается не один, а указанное количество элементов, и в случае возникновения ожидания оно продолжается до тех пор, пока в канале не окажется нужное количество элементов или не сработает таймаут, если он был задействован;

#### <u>read inside ISR</u>

###### Прототип

```cpp
template<typename T, uint16_t Size, typename S>
S OS::channel<T, Size, S>::read_isr(T *const data, const S max_size);
```

###### Описание

Специальная версия при использовании внутри обработчиков прерываний. Функция читает столько элементов, сколько их присутствует в канале (но не более указанного количества), возвращает количество записанных элементов. При этом процессы, ожидавшие появление свободного места в канале, переводятся в состояние готовых к выполнению.

Вызов неблокирующий. Планировщик не вызывается.

#### <u>get item count</u>

###### Прототип

```cpp
template<typename T, uint16_t Size, typename S>
S OS::channel<T, Size, S>::get_count();
```

###### Описание

Возвращает величину количества элементов в канале. Функция является встраиваемой, поэтому эффективность её работы максимально высока;

#### <u>get free size</u>

###### Прототип

```cpp
template<typename T, uint16_t Size, typename S>
S OS::channel<T, Size, S>::get_free_size();
```

###### Описание

Возвращает размер свободного пространства в канале.

#### <u>flush</u>

###### Прототип

```cpp
template<typename T, uint16_t Size, typename S>
S OS::channel<T, Size, S>::flush();
```

###### Описание

Производит очистку канала. Функция очищает буфер путём вызова `usr::ring_buffer<>::flush()` и вызывает планировщик.

[^24]: Имеется в виду очередь канала. Т.к. функционально канал представляет собой FIFO, то конец очереди соответствует входу FIFO, начало канала – выходу FIFO.

[^25]: Т.е. вызов был с передачей вторым аргументом целого числа, которое и задает величину таймаута в тиках системного  таймера.

### Пример использования

Простой пример использования&nbsp;– см.&nbsp;"Листинг&nbsp;12. Пример использования очереди на основе канала".

```cpp
01    //---------------------------------------------------------------------
02    struct Cmd
03    {
04        enum CmdName { cmdSetCoeff1, cmdSetCoeff2, cmdCheck } CmdName;
05        int Value;
06    };
07    
08    OS::channel<Cmd, 10> cmd_q; // Queue for Commands with 10 items depth
09    //---------------------------------------------------------------------
10    template<> void Proc1::exec()
11    {
12        ...
13        Cmd cmd = { cmdSetCoeff2, 12 };
14        cmd_q.push(cmd);
15        ...
16    }
17    //---------------------------------------------------------------------
18    template<> void Proc2::exec()
19    {
20        ...
21        Cmd cmd;
22        if( cmd_q.pop(cmd, 10) ) // wait for data, timeout 10 system ticks
23        {
24            ... // data incoming, do something
25        }
26        else
27        {
28            ... // timeout expires, do something else
29        }
30        ...
31    }
32    //---------------------------------------------------------------------
```
/// Caption
Листинг 12. Пример использования очереди на основе канала.
///

Как видно, использование достаточно простое и прозрачное. В одном процессе (Proc1) создаётся сообщение-команда cmd (13), инициализируется требуемыми значениями и записывается в очередь-канал (14). В другом процессе (Proc2) происходит ожидание данных из очереди (22), при приходе данных выполняется соответствующий код (23)-(25), при истечении таймаута выполняется другой код (27)-(29).

----

## Заключительные замечания

Существует некий инвариант между различными средствами межпроцессного взаимодействия. Т.е. с помощью одних средств (или, что чаще, их совокупности) можно выполнить ту же задачу, что и с помощью других. Например, вместо использования канала можно создать статический массив и обмениваться данными через него, используя семафоры взаимоисключения для предотвращения совместного доступа и флаги события для уведомления ожидающего процесса, что данные для него готовы. В ряде случаев такая реализация может оказаться более эффективной, хотя и менее удобной. 

Можно использовать сообщения для синхронизации по событиям вместо флагов событий&nbsp;– такой поход имеет смысл в случае, если вместе с флагом нужно ещё передать какую-то информацию. Собственно, OS::message именно для этого и предназначен. Разнообразие использования велико, и какой вариант подходит наилучшим образом в той или иной ситуации, определяется, в первую очередь, самой ситуацией.

!!! info "**СОВЕТ**"
  
    Необходимо понимать и помнить, что любое средство межпроцессного взаимодействия при выполнении своих функций делает это в критической секции, т.е. при запрещённых прерываниях. Исходя из этого, не следует злоупотреблять средствами межпроцессного взаимодействия там, где можно обойтись без них.

    Например, при обращении к статической переменной встроенного типа использовать семафор взаимоисключения не является хорошей идеей по сравнению с простым использованием критической секции, т.к. семафор при захвате и освобождении тоже использует критические секции, пребывание в которых дольше, чем при простом обращении к переменной.

При использовании сервисов в прерываниях есть определённые особенности. Например, очевидно, что использовать `TMutex::lock()` внутри обработчика прерывания является достаточно плохой идеей, т.к., во-первых, семафоры взаимоисключения предназначены для разделения доступа к ресурсам на уровне процессов, а не на уровне прерываний, и, во-вторых, ожидать освобождения ресурса, если он был занят, внутри обработчика прерывания все равно не удастся и это приведёт только к тому, что процесс, прерванный данным прерыванием, просто будет переведён в состояние ожидания в неподходящей и непредсказуемой точке. Фактически процесс будет переведён в неактивное состояние, из которого его вывести можно будет только с помощью функции `TBaseProcess::force_wake_up()`. В любом случае ничего хорошего из этого не получится.

Аналогичная в некотором роде ситуация может получиться при использовании объектов-каналов в обработчике прерываний. Ждать данных из канала внутри ISR не получится, и последствия будут аналогичны вышеописанным, а записывать данные в канал тоже не вполне безопасно. Если, к примеру, при записи в канал в нем не окажется достаточно места, то поведение программы окажется далеко не таким, как ожидает пользователь.

!!! warning "**РЕКОМЕНДАЦИЯ**"

    Для работы внутри прерываний следует использовать функции-члены сервисов с суффиксом `_isr`&nbsp;– это специально разработанные версии, которые обеспечивают эффективность и безопасность использования средств межпроцессного взаимодействия внутри прерываний.

Ну и, конечно же, в случае, если имеющийся набор средств межпроцессного взаимодействия по каким-то причинам не удовлетворяет потребностей того или иного проекта, всегда есть возможность спроектировать сервисный класс под собственные нужды, опираясь на предоставленную базу в виде TService. При этом штатный набор сервисов можно использовать в качестве примеров для проектирования.

