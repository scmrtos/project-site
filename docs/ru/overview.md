# Обзор операционной системы

## Общие сведения

**scmRTOS** является операционной системой реального времени с приоритетной вытесняющей многозадачностью. ОС поддерживает до 32 процессов (включая системный процесс **IdleProc**, т.е. до 31 пользовательского процесса), каждый из которых имеет уникальный приоритет. Все процессы статические, т.е. их количество определяется на этапе сборки проекта и они не могут быть добавлены или удалены во время исполнения. 

<a name="avoid-dynamic-process"></a>
Отказ от динамического создания процессов обусловлен соображениями экономии ресурсов, которые в однокристальных МК весьма ограничены. Динамическое удаление процессов также не реализовано, т.к. в этом немного смысла&nbsp;– память программ, используемая процессом, при этом не освобождается, а ОЗУ для последующего использования должно иметь возможность быть выделяемым/освобождаемым с помощью диспетчера памяти, который сам по себе достаточно непростая вещь, требует приличного количества ресурсов и, как правило, не используется в проектах на однокристальных МК[^1].

В текущей версии приоритеты процессов также статические, т.е. каждый процесс получает приоритет на этапе сборки проекта и приоритет не может быть изменён во время выполнения программы. Такой подход также обусловлен стремлением сделать систему как можно более лёгкой в части требований к ресурсам и динамичной, т.к. изменение приоритетов в процессе функционирования системы -  совсем нетривиальный механизм, который для корректной работы требует анализа состояния всей системы (ядра, сервисов) с последующей модификацией составляющих ядра и остальных частей ОС (семафоров, флагов событий и проч.), что неизбежно порождает длительные периоды работы при блокированных прерываниях и, как следствие, значительно ухудшает динамические характеристики системы. 

[^1]: Имеется в виду стандартный менеджер памяти, поставляемый в составе средств разработки. Существуют ситуации, когда для работы программы необходимо хранить данные между вызовами функций (т.е. автоматический класс хранения данных&nbsp;– на стеке/в регистрах процессора&nbsp;– не подходит), и при этом  на этапе компиляции программы неизвестно, сколько всего будет этих данных&nbsp;– их появление и время жизни определяются событиями, возникающими на этапе выполнения программы. Для хранения таких данных наилучшим образом подходит размещение их в т.н. свободной памяти&nbsp;– в "куче". Эти действия, как правило, возлагаются на менеджер памяти.

    Поэтому в ряде приложений без такого средства не обойтись,  но учитывая потребление ресурсов стандартным менеджером памяти, его применение оказывается неприемлемым. В этой ситуации нередко используют специализированный менеджер памяти, спроектированный специально для удовлетворения требований прикладной задачи оптимальным образом. Принимая во внимание вышесказанное, становится очевидным, что создание универсального менеджера памяти, в равной степени хорошо удовлетворяющего потребностям разнообразных проектов, малореально, что обусловило отсутствие менеджера памяти в составе **scmRTOS**.

## Структура ОС
Система состоит из трёх основных составных частей: ядра (Kernel), процессов и средств межпроцессного взаимодействия.

### Ядро

Ядро осуществляет:

  * функции по организации процессов;
  * планирование (Scheduling) как на уровне процессов, так и на уровне прерываний;
  * поддержку межпроцессного взаимодействия;
  * поддержку системного времени (системный таймер);
  * поддержку расширений.

Подробнее о структуре, составе, функциях и механизмах ядра [см. раздел "Ядро ОС"](kernel.md).


### Процессы

Процессы предоставляют возможность создавать отдельный (асинхронный по отношению к остальным) поток управления программы, который реализуется в виде функции, связанной с процессом. Такая функция называется *исполняемой функцией процесса*. 

Исполняемая функция должна содержать бесконечный цикл, являющийся главным циклом процесса&nbsp;– пример см. "Листинг 1. Исполняемая функция процесса".

<a name="process-exec"></a>
```cpp
1    template<> void slon_proc::exec()
2    {
3        ... // Declarations
4        ... // Init process’s data
5        for(;;)
6        {
7            ... // process’s main loop
8        }
9    }
```

/// Caption
Листинг 1. Исполняемая функция процесса
///

При старте системы управление передаётся в функцию процесса, где на входе могут быть размещены объявления используемых данных (3) и код инициализации (4), за которыми следует главный цикл процесса (5)-(8). Пользовательский код должен быть написан так, чтобы исключить выход из функции процесса. Например, войдя в главный цикл, не покидать его (основной подход), либо, если выйти из главного цикла, то попасть или в другой цикл (пусть даже пустой), или в бесконечную "спячку", вызвав функцию `sleep()`[^2] без параметров (или с параметром "0"),&nbsp;– подробнее об этом см. [Функция `sleep()`](processes.md#process-sleep). В коде процесса не должно также быть операторов возврата из функции `return`.

[^2]: При этом никакой другой процесс не должен "будить" этот спящий перед выходом процесс, иначе возникнет неопределенное поведение и система, скорее всего, "упадет". Единственным безопасным действием, которое может быть применено к процессу в этой ситуации&nbsp;– это прекращение работы процесса (с возможностью дальнейшего запуска его с начала), см. [Перезапуск процесса](processes.md#process-restart).

!!! info "**ЗАМЕЧАНИЕ**"

    В представленном примере роль исполняемой функции процесса играет функция (`exec()`)&nbsp;–  статическая функция-член класса, описывающего тип процесса. Это не единственная возможность определить исполняемую функцию процесса: кроме статической функции-члена может быть использована любая функция вида `void fun()`, адрес которой требуется передать конструктору процесса, в том числе может быть использовано встраивание тела функции в аргумент конструктора с помощью механизма лямбда-функции С++. Подробнее об этом в разделе ["Альтернативные способы объявления объекта процесса"](processes.md#process-alternate-exec)

### Межпроцессное взаимодействие

Так как процессы в системе выполняются параллельно и асинхронно по отношению друг к другу, то простое использование глобальных данных для обмена между ними некорректно и опасно: во время обращения к тому или иному объекту (который может быть переменной встроенного типа, массивом, структурой, объектом класса и проч.) со стороны одного процесса может произойти прерывание его работы другим (более приоритетным) процессом, который также производит обращение к тому же объекту, и, в силу неатомарности операций обращения (чтение/запись), второй процесс может как нарушить правильность действий первого процесса, так и просто считать некорректные данные.
Для предотвращения таких ситуаций нужно принимать специальные меры: производить обращение внутри так называемых критических секций (Critical Section), когда передача управления между процессами запрещена, или использовать специальные средства для межпроцессного взаимодействия. К таким средствам в **scmRTOS** относятся:

  * флаги событий (`OS::TEventFlag`);
  * семафоры взаимоисключения (`OS::TMutex`);
  * каналы для передачи данных в виде очереди из байт или объектов произвольного типа (`OS::channel`);
  * сообщения (`OS::message`).

Какое из средств (или их совокупность) применить в каждом конкретном случае, должен решать разработчик, исходя из требований задачи, доступных ресурсов и личных предпочтений.
Начиная с **scmRTOS v4**, средства межпроцессного взаимодействия (сервисы) выполнены  на основе общего специализированного класса `TService`, который предоставляет все необходимые базовые средства для реализации сервисных классов/шаблонов. Интерфейс этого класса документирован и предназначен для расширения набора сервисов самим пользователем, который при необходимости может спроектировать и реализовать своё собственное средство межпроцессного взаимодействия, наилучшим образом отвечающее требованиям конкретного целевого проекта.


## Программная модель

### Состав и организация

Исходный код **scmRTOS**  в любом проекте состоит из трёх частей: общая (core) и платформеннозависимая (target), и проектнозависимая (project).
Общая часть содержит объявления и определения функций ядра, процессов, системных сервисов, а также  небольшую библиотеку поддержки, содержащую некоторый полезный код, часть которого непосредственно используется ОС.

Платформеннозависимая часть&nbsp;– объявления и определения, отвечающие за реализацию функций, присущих данной целевой платформе, расширения языка для используемого компилятора и т.п. К платформеннозависимой части относятся ассемблерный код переключения контекста и старта системы, функция формирования структуры стекового кадра (stack frame), определение класса-"обёртки" (wrapper) критической секции, а также обработчик прерывания от аппаратного таймера данной платформы, используемого в качестве системного, и другое платформеннозависимое поведение.

Проектнозависимая часть&nbsp;– три заголовочных файла с определениями конфигурационных макросов, подключениями расширений и необходимого в ряде случаев кода для тонкой настройки операционной системы под конкретный целевой проект&nbsp;– в частности, сюда входят определения псевдонимов типов для задания разрядности переменных таймаутов, выбор источника прерывания переключения контекстов и другие необходимые для оптимального функционирования системы средства.

Рекомендуемое размещение исходных файлов системы: общая часть&nbsp;– в отдельной директории core, платформеннозависимая часть&nbsp;– в своей директории `<target>`, где `target`&nbsp;– название целевого порта системы, проектнозависимая часть&nbsp;– непосредственно в исходных файлах проекта. Такое размещение предлагается из соображений удобства хранения, переноса и сопровождения проекта, а также более простого и безопасного процесса обновления системы при переходе на новые версии.

Исходные тексты общей части содержатся в восьми файлах:

  * **scmRTOS.h**. Главный заголовочный файл, включает в себя всю иерархию заголовочных файлов системы;
  * **os_kernel.h**. Основные объявления и определения типов ядра ОС;
  * **os_kernel.cpp**. Объявления объектов и определения функций ядра;
  * **scmRTOS_defs.h**. Вспомогательные объявления и макросы;
  * **os_services.h**. Определения типов и шаблонов сервисов;
  * **os_services.cpp**. Определения функций сервисов;
  * **usrlib.h**. Определения типов и шаблонов библиотеки поддержки4
  * **usrlib.cpp**. Определения функций библиотеки поддержки.

Как видно из вышеприведённого списка, в состав **scmRTOS** входит ещё небольшая библиотека поддержки, где находится код, используемый средствами ОС[^3].  Поскольку сама по себе эта библиотека по сути не является частью ОС, то внимания её (библиотеки) рассмотрению в текущем документе уделено не будет.

[^3]: В частности, класс/шаблон кольцевого буфера.

Исходный код платформеннозависимой части находится в трёх файлах:

   * **os_target.h**. Платформеннозависимые объявления и макросы;
   * **os_target_asm.ext**[^4]. Низкоуровневый код, функции переключения контекста, старта ОС;
   * **os_target.cpp**. Определения функции инициализации стекового кадра процесса и функции обработчика прерывания от таймера, используемого в качестве системного, корневая функция фонового (idle) процесса.

[^4]: Расширение ассемблерного файла для целевого процессора.

Проектнозависимая часть состоит из трёх заголовочных файлов:

  * **scmRTOS_config.h**. Конфигурационные макросы и псевдонимы некоторых типов, в частности, типа, задающего разрядность объектов таймаутов;
  * **scmRTOS_target_cfg.h**. Код для настройки механизмов ОС под нужды конкретного проекта; сюда, например, может входить задание вектора прерываний для обработчика прерываний от аппаратного таймера, выбранного в качестве системного, макросы управления системным таймером, определение функции активации прерывания переключения контекстов и др;
  * **scmRTOS_extensions.h**. Управление подключением расширений. Более подробно см. [TKernelAgent и расширения](kernel.md#kernel-agent).

### Внутренняя структура

Все, что относится к **scmRTOS**, за исключением нескольких функций, реализованных на ассемблере и имеющих спецификацию связывания `extern “C”`, помещено внутрь пространства имён OS&nbsp;– таким способом реализовано отдельное пространство имён для составных частей операционной системы.
Внутри этого пространства имён объявлены следующие классы[^5]:

  * `TKernel`. Поскольку ядро в системе может быть представлено только в одном экземпляре, то существует только один объект этого класса. Пользователь не должен создавать объекты этого класса;
  * `TBaseProcess`. Реализует тип объекта, являющегося основой для построения шаблона process, на основе которого реализуется любой (пользовательский или системный) процесс;
  * `process`. Шаблон, на основе которого создаётся тип любого процесса ОС.
  * `TISRW`. Это класс-"обёртка" для облегчения и автоматизации процедуры создания кода обработчиков прерываний. Его конструктор выполняет действия при входе в обработчик прерывания, а деструктор – соответствующие действия при выходе. 
  * `TKernelAgent`. Специальный служебный класс, предназначенный для предоставления доступа к необходимым ресурсам ядра для расширения возможностей ОС. На основе этого класса построены класс `TService`, являющийся базой для всех средств межпроцессного взаимодействия, а  также [шаблон класса профилировщика процессов](profiler.md).

[^5]: Почти все классы ОС объявлены как друзья (friend) друг для друга. Это сделано для того, чтобы обеспечить доступ для составных частей ОС к представлению других составных частей, не открывая интерфейс наружу, чтобы пользовательский код не мог напрямую использовать внутренние переменные и механизмы ОС, что повышает безопасность использования.  

В перечень сервисных классов входят:

  * `TService`. Базовый класс для построения всех типов и шаблонов средств межпроцессного взаимодействия. Содержит общий функционал и определяет интерфейс прикладного программирования&nbsp;– API (Application Programming Interface) для всех типов-потомков. Является основой для расширения набора средств межпроцессного взаимодействия.
  * `TEventFlag`. Предназначен для межпрограммных взаимодействий путём передачи бинарного семафора (флага события);
  * `TMutex`. Бинарный семафор, предназначенный для организации взаимного исключения доступа к совместно используемым ресурсам;
  * `message`. Шаблон для создания объектов-сообщений Сообщение "похоже" на флаг событий, но вдобавок может ещё содержать объект произвольного типа (обычно это структура), представляющий собой тело сообщения;
  * `channel` . Шаблон для создания канала передачи данных произвольного типа. Служит основой для построения очередей сообщений.

Из приведённого выше списка видно, что отсутствуют счётные семафоры. Причина этого в том, что при всем желании не удалось увидеть острой необходимости в них. Ресурсы, которые нуждаются в контроле с помощью счётных семафоров, находятся в остром дефиците в однокристальных МК, это прежде всего&nbsp;– оперативная память. А ситуации, где все же необходимо контролировать доступное количество, обходятся с помощью объектов, созданных на основе шаблона `OS::channel`, внутри которых в том или ином виде уже реализован соответствующий механизм.

При необходимости в таком сервисе пользователь может самостоятельно добавить его к базовому набору путём создания своей реализации в виде расширения, см. [TKernelAgent и расширения](kernel.md#kernel-agent).

**scmRTOS** предоставляет пользователю несколько функций для контроля:

  * `run()`. Предназначена для запуска ОС. При вызове этой функции начинается собственно функционирование операционной системы&nbsp;– управление передаётся процессам, работа которых и взаимное взаимодействие определяется пользовательской программой. Передав управление коду ядра ОС, функция уже не получает его (управление) обратно и, следовательно, возврата из функции не предусмотрено;
  * `lock_system_timer()`. Блокирует прерывания от системного таймера. Поскольку выбор и обслуживание аппаратной части системного таймера находятся в компетенции проекта, то определить содержимое этой функции должен пользователь. То же самое касается и парной функции `unlock_system_timer()`;
  * `unlock_system_timer()`. Разблокирует прерывания от системного таймера;
  * `get_tick_count()`. Возвращает количество тиков системного таймера. Счётчик тиков системного таймера должен быть разрешён при конфигурировании системы;
  *  `get_proc()`. Возвращает указатель на константный объект процесса по индексу, переданному в функцию в качестве аргумента. Индекс фактически является значением приоритета процесса.

### Критические секции

В силу вытесняющего характера работы процессов, любой из них может быть прерван в произвольный момент времени. С другой стороны, существует ряд случаев[^6], когда необходимо исключить возможность прервать процесс во время выполнения определённого фрагмента кода. Это достигается запрещением передачи управления[^7] на период выполнения упомянутого фрагмента. Т.е. этот фрагмент является как бы непрерываемой секцией.

[^6]: Например, обращение к переменным ядра ОС или представлению средств межпроцессного взаимодействия.
[^7]: В **scmRTOS** в настоящее время это достигается путём общего запрещения прерываний.

В терминах ОС такая секция называется критической. Для упрощения организации критической секции используется специальный класс-"обёртка" `TCritSect`. В конструкторе этого класса запоминается состояние процессорного ресурса, управляющего общим разрешением/запрещением прерываний, и прерывания запрещаются. В деструкторе этот процессорный ресурс приводится к тому состоянию, в котором он пребывал перед запрещением прерываний.

Таким образом, если прерывания были запрещены, то они и останутся запрещёнными. Если были разрешены, то будут разрешены. Реализация этого класса платформеннозависима, поэтому её определение содержится в соответствующем файле os_target.h.
Использование `TCritSect` тривиально: в точке, которая соответствует началу критической секции, достаточно объявить объект этого типа, и от места объявления до конца блока прерывания будут запрещены[^8].

[^8]: При выходе из блока автоматически будет вызван деструктор, который восстановит состояние, предшествовавшее входу в критическую секцию. Т.е. при таком способе отсутствует возможность "забыть" разрешить прерывания при выходе из критической секции.

### Синонимы встроенных типов

Для облегчения работы с исходным текстом, а также для переносимости введены следующие синонимы:

  * `TProcessMap`&nbsp;– тип для определения переменной, выполняющий функцию карты процессов. Её размер зависит от количества процессов в системе. Каждому процессу соответствует уникальный тег&nbsp;– маска, содержащая только один ненулевой бит, расположенный в соответствии с приоритетом этого процесса. Процессу с наибольшим приоритетом соответствует младший бит (позиция 0)[^9]. При количестве пользовательских процессов менее 8 размер карты процессов&nbsp;– 8 бит. При количестве от 8 до 15 размер&nbsp;– 16 бит, при 16 и более пользовательских процессов&nbsp;– 32 бита.
  * `stack_item_t`&nbsp;– тип элемента стека. Зависит от целевой архитектуры. Например, на 8-разрядном **AVR** этот тип определён как `uint8_t`, на 16-разрядном **MSP430** – `uint16_t`, а на 32-разрядных платформах, как правило,&nbsp;– `uint32_t`.

### Использование ОС

Как уже отмечалось выше, для достижения максимальной эффективности везде, где возможно, использовались статические механизмы, т.е. вся функциональность определяется на этапе компиляции.

В первую очередь это касается процессов. Перед использованием каждого процесса должен быть определён его тип[^10], где указывается имя типа процесса, его приоритет и размер области ОЗУ, отведённой под [стек процесса](processes.md#process-stack). Например:

[^9]:Такой порядок принят по умолчанию. Если `scmRTOS_PRIORITY_ORDER` определён как 1, то порядок расположения бит в карте процессов обратный&nbsp;– т.е. старший бит соответствует наиболее приоритетному процессу, младший бит&nbsp;– наименее приоритетному. Обратный порядок приоритетов может оказаться полезным для процессоров, у которых есть аппаратные средства поиска первого ненулевого бита в двоичном слове,&nbsp;– например для процессоров семейства **Blackfin**.

[^10]: Каждый процесс&nbsp;– это объект отдельного типа (класса), производного от общего базового класса `TBaseProcess`. 

```cpp
OS::process<OS::pr2, 200> MainProc;
```

Здесь определён процесс с приоритетом `pr2` и размером стека в 200 байт. Такое объявление может показаться несколько неудобным из-за некоторой многословности, т.к. при необходимости ссылаться на тип процесса придётся писать полное объявление – например, при определении исполняемой функции процесса[^11]:

[^11]: Исполняемая функция конкретного процесса технически является полной специализацией функции-члена шаблона `OS::process::exec()`, поэтому в её определении используется синтаксис определения специализации `template<>`.

```cpp
template<> void OS::process<OS::pr2, 200>::exec() { ... }
```

т.к. типом является именно выражение 

```cpp
OS::process<OS::pr2, 200>
```

Аналогичная ситуация возникнет и в других случаях, когда понадобится ссылаться на тип процесса. Для устранения этого неудобства можно пользоваться синонимами типов, вводимыми через `typedef`/`using`. Это рекомендуемый стиль кодирования: сначала определить псевдонимы типов процессов (лучше всего где-нибудь в заголовочном файле в одном месте, чтобы сразу было видно, сколько в проекте процессов и какие они), а потом уже по месту в исходных файлах объявлять сами объекты процессов. При этом приведённый выше пример выглядит так[^12]:

[^12]: Рекомендуется объявлять прототип специализации исполняемой функции процесса до первого использования экземпляра шаблона&nbsp;– это позволит компилятору видеть, что существует полная специализация функции для данного экземпляра, поэтому нет необходимости пытаться сгенерировать общую реализацию этой функции шаблона. В ряде случаев это позволяет избежать ошибок компиляции. 

```cpp
// В заголовочном файле
typedef OS::process<OS::pr2, 200> TMainProc;
...
template<> void TMainProc::exec();

// В исходном файле
TMainProc MainProc;
...
template<> void TMainProc::exec()
{
    ...
}
...
```
В этой последовательности действий нет ничего особенного&nbsp;– это обычный способ описания псевдонима типа и создания объекта этого типа, принятый в языках программирования С и С++.

!!! warning "**ВАЖНОЕ ЗАМЕЧАНИЕ**"

    При конфигурации системы должно быть указано количество процессов. И это количество должно точно совпадать с количеством описанных процессов в проекте, иначе система работать не будет. Следует иметь в виду, что для задания приоритетов введён специальный перечислимый тип `TPriority`, который описывает допустимые значения приоритетов[^13].

    Кроме того, приоритеты всех процессов должны идти подряд, пропусков не допускается, например, если в системе 4 процесса, то приоритеты процессов должны иметь значения `pr0`, `pr1`, `pr2`, pr3. Не допускаются также одинаковые значения приоритетов, т.е. каждый процесс должен иметь уникальное значение приоритета. Например, если в системе 4 пользовательских процесса (т.е. всего 5 процессов – один системный процесс `IdleProc`), то значения приоритетов должны быть `pr0`, `pr1`, `pr2`, `pr3` (`prIDLE`&nbsp;– для `IdleProc`), где `pr0`&nbsp;– самый высокоприоритетный процесс, а `pr3`&nbsp;– самый низкоприоритетный из пользовательских процессов. Вообще самым низкоприоритетным процессом является `IdleProc`. Этот процесс существует в системе всегда, его описывать не нужно. Именно этот процесс получает управление, когда все пользовательские процессы находятся в неактивном состоянии. 

    За пропусками в нумерации приоритетов процессов, а также за уникальностью значений приоритетов процессов компилятор не следит, т.к., придерживаясь принципа раздельной компиляции, не видно эффективного пути сделать автоматизированный контроль за целостностью конфигурации языковыми средствами.

    В настоящее время существует специальное инструментальное средство, которое выполняет всю работу по проверке целостности конфигурации. Утилита называется scmIC (IC – Integrity Checker), и позволяет обнаружить подавляющее большинство типовых ошибок конфигурирования ОС.

[^13]: Это сделано для повышения безопасности использования&nbsp;– нельзя просто указать любое целое значение, подходят только те значения, которые описаны в `TPriority`. А описанные в `TPriority` значения связаны с количеством процессов, указанном при задании конфигурационного макроса `scmRTOS_PROCESS_COUNT`. Таким образом, можно только выбрать из ограниченного количества. Значения приоритетов процессов имеют вид: `pr0`, `pr1` и т.д., где число обозначает уровень приоритета. Системный процесс `IdleProc` имеет отдельное обозначение приоритета `prIDLE`.

Как уже было сказано, определение типов процессов удобно разместить в заголовочном файле, чтобы была возможность легко сделать любой процесс видимым в другой единице компиляции.

Пример типового использования процессов – см.&nbsp;"Листинг&nbsp;2. Определение типов процессов в заголовочном файле" и "Листинг&nbsp;3. Объявление процессов в исходном файле и запуск ОС".

```cpp
01    //------------------------------------
02    //
03    // Process types definition
04    //
05    //
06    typedef OS::process<OS::pr0, 200> UartDrv;
07    typedef OS::process<OS::pr1, 100> LcdProc;
08    typedef OS::process<OS::pr2, 200> MainProc;
09    typedef OS::process<OS::pr3, 200> Fpga_Proc;
10    //-------------------------------------
```
/// Caption
Листинг 2. Определение типов процессов в заголовочном файле
///

```cpp
01    //-------------------------------------
02    //
03    // Processes declarations
04    //
05    //
06    UartDrv  uart_drv;
07    LcdProc  lcd_proc;
08    MainProc main_roc;
09    FpgaProc fpga_proc;
10    //-------------------------------------
11
12    //-------------------------------------
13    void main()
14    {
15        ... // system timer and other stuff initialization
16        OS::run();
17    }
18    //-------------------------------------
```
/// Caption
Листинг 3. Объявление процессов в исходном файле и запуск ОС
///

Каждый процесс, как уже упоминалось выше, имеет исполняемую функцию. При использовании приведённой выше схемы исполняемая функция процесса называется exec и выглядит как показано на "Листинг 1. Исполняемая функция процесса".

Конфигурационная информация задаётся в специальном заголовочном файле scmRTOS_config.h. Состав и значения[^14] конфигурационных макросов&nbsp;– см.&nbsp;"Таблица 1. Конфигурационные макросы".

[^14]: В таблице приведены примеры значений. В каждом проекте значения задаются индивидуально, исходя из требований проекта.

| Название  | Значение  | Описание  |
|-----------|-----------|-----------|
| `scmRTOS_PROCESS_COUNT`  | n  | Количество процессов в системе  |
| `scmRTOS_SYSTIMER_NEST_INTS_ENABLE` | 0/1 | Разрешает вложенные прерывания в обработчике прерывания<br>от системного таймера[^15] |
| `scmRTOS_SYSTEM_TICKS_ENABLE` | 0/1 | Включает использование счётчика тиков системного таймера |
| `scmRTOS_SYSTIMER_HOOK_ENABLE` | 0/1 | Включает в обработчике прерывания системного таймера <br>вызов функции `system_timer_user_hook()`. В этом случае<br>указанная функция должна быть определена в<br> пользовательском коде |
| `scmRTOS_IDLE_HOOK_ENABLE` | 0/1 | Включает в системном процессе `IdleProc` вызов<br>функции `idle_process_user_hook()`. В этом случае<br>указанная функция должна быть определена в<br> пользовательском коде |
| `scmRTOS_ISRW_TYPE` | `TISRW`<br>`TISRW_SS` | Позволяет выбрать тип класса-"обёртки" для обработчика<br>прерывания системного таймера&nbsp;– обычный или с<br>переключением на отдельный стек прерываний.<br>Суффикс&nbsp;`_SS` означает Separate Stack |
| `scmRTOS_CONTEXT_SWITCH_SCHEME` | 0/1 | Задаёт способ переключения контекстов (передачи<br>управления) |
| `scmRTOS_PRIORITY_ORDER` | 0/1 | Задаёт порядок старшинства приоритетов в карте процессов.<br>Значение 0 соответствует варианту, когда наиболее<br>приоритетный процесс соответствует младшему биту в карте<br>процессов (`TProcessMap`), значение 1 соответствует<br> варианту, когда наиболее приоритетному процессу<br> соответствует старший бит (из значимых) в карте процессов |
| `scmRTOS_IDLE_PROCESS_STACK_SIZE` | N | Задаёт размер стека фонового процесса IdleProc |
| `scmRTOS_CONTEXT_SWITCH_USER_HOOK_ENABLE` | 0/1 | Разрешает вызов пользовательского хука<br>`context_switch_user_hook()`  во время переключения контекстов. В этом случае функция<br>должна быть определена в пользовательском коде |
| `scmRTOS_DEBUG_ENABLE` | 0/1 | Включает отладочные средства |
| `scmRTOS_PROCESS_RESTART_ENABLE` | 0/1 | Позволяет прерывать работу любого  процесса в<br> произвольный момент и запустить этот процесс заново |

/// Caption
Таблица 1. Конфигурационные макросы
///

[^15]: Если портом поддерживается только один вариант, то соответствующее значение макроса определено в порте. Это же самое касается и всех остальных макросов.



